<!DOCTYPE html>
<html>
  <head>
    
    
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  Fluent Python 読書メモ &ndash; 矢吹の読書会記録

    </title>
    
    
    <meta name="description" property="og:description" content="はじめに Fluent Pythonを読むにあたって、「本を読む本」のなかで問われている問いに答える形で、読書メモを作っていこうと思う。 「初級読書」 &amp;mdash; これ|読書会の記録を残すサイト">
    

    <meta name="apple-mobile-web-app-title" content="矢吹の読書会記録">
    
    
    
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@YukiharuYABUKI">
    <meta name="twitter:creator" content="@YukiharuYABUKI">
    <meta name="twitter:title" content="Fluent Python 読書メモ | 矢吹の読書会記録">
    <meta name="twitter:description" content="はじめに Fluent Pythonを読むにあたって、「本を読む本」のなかで問われている問いに答える形で、読書メモを作っていこうと思う。 「初級読書」 &mdash; これ|読書会の記録を残すサイト">
    <meta name="twitter:image" content="http://yabuki.github.io/BookClub/twitter-card.png">
    


    <link rel="stylesheet" href="/BookClub/assets/syntax.css">
    <link rel="stylesheet" href="/BookClub/assets/primer-build.css">
    <link rel="stylesheet" href="/BookClub/assets/style.css">
    <link rel="stylesheet" href="/BookClub/assets/custom_style.css">
  </head>


  <body class="bg-gray">
    <div id="holy" class="container-lg bg-white h-100">

      <div id="header" class="px-1 bg-white">
        <nav class="UnderlineNav UnderlineNav--right px-2">
  <a class="UnderlineNav-actions muted-link h2" href="http://yabuki.github.io/BookClub/">
    矢吹の読書会記録
  </a>

  
  
  <div class="UnderlineNav-body">
    
    
    
    <a class="UnderlineNav-item" href="/BookClub/">
      
      <span>読書会トップページ</span>
    </a>
    
    
    
    
    <a class="UnderlineNav-item" href="/BookClub/about/">
      
      <span>About</span>
    </a>
    
    
    
    
    <a class="UnderlineNav-item" href="/BookClub/todo/">
      
      <span>ToDo</span>
    </a>
    
    
  </div>
  
</nav>

      </div>

      <div role="main" id="main" class="holy-main markdown-body px-4 bg-white">
        

<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">Fluent Python 読書メモ</div>
  </div>
  <div class="Subhead-description">
    


<a href='/BookClub/categories/%E8%AA%AD%E6%9B%B8%E3%83%A1%E3%83%A2' class="muted-link">
  <span class="Label Label--gray-darker">読書メモ</span>
</a>



<a href='/BookClub/tags/python' class="muted-link">
  <span class="Label Label--gray">Python</span>
</a>

<a href='/BookClub/tags/fluentpython' class="muted-link">
  <span class="Label Label--gray">FluentPython</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2020-08-02. Published at: 2020-07-10.">
        
          Lastmod: 2020-08-02
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom">
    <h2 id="はじめに">はじめに</h2>
<p>Fluent Pythonを読むにあたって、「本を読む本」のなかで問われている問いに答える形で、読書メモを作っていこうと思う。</p>
<ol>
<li>「初級読書」 &mdash; これは、「その文は何を述べているか」を確認するのであるが、誤読していることもあるので侮れない。まま、このレベルに戻ることもあろう。
<ol>
<li>「読み方準備期」</li>
<li>ごく簡単な読み方を覚える</li>
<li>文脈をたどって知らない単語の意味をつかむ。</li>
<li>1つの作品から得た概念を消化して次の書籍を読む。1つの主題について幾人かの著者が述べることを比較することができるようになる。(ここに至ることができないこともある)</li>
</ol>
</li>
<li>「点検読書」 &mdash;  時間に重点を置いて、「系統だって拾い読み」をする技術を指す。今回は、緩急を付けて読んでいるので、これに該当するとおもう。
<ul>
<li>「この本は何について書いたものであるか」</li>
<li>「この本はどのように構成されているか」</li>
<li>「どのような部分に分けられているか」</li>
<li>「この本は、どういう種類の本か」</li>
</ul>
</li>
<li>分析読書</li>
<li>シントピカル読書」(他の本と比較しつつ読む)</li>
</ol>
<p>と、「批判的読書のコツ 20のポイント」も押さえたい。あと、分析読書をいうか、内容を噛み砕く時の手がかり、足がかりのメモも残したい。</p>
<h2 id="対象としている読者">対象としている読者</h2>
<p>page xiiにある。</p>
<p>python以外から、pythonを書くようになったプログラマーが、これまで培ったプログラミングのノウハウを越えて、<strong>「pythonらしい」</strong> プログラムを書きたい場合に参照する本であり、python3を使いこなしたい人向けであるとのこと。</p>
<p>一定以上pythonを理解している必要があるので、読者はオススメしてあるドキュメントやチュートリアルをやっておく必要があるかもしれない。</p>
<p>また、python初心者がこの本を読むと、なんでもこの本に書いてあることを実践したくなるので、止めた方がいいともある。知っていて使わないという選択ができないと有害でもある。</p>
<hr>
<p><em>yabuki (注)</em></p>
<p>読み進めるにつれて、対象の読者は、pythonの一通りについて分かっていて、用語もばっちりokという感じでないと、ふんふんと読み進めることは厳しいかも。こうやって読書メモを作る習慣がないと読みきるのも辛いかも。一人じゃなくて仲間で分担したほうがいいね。</p>
<p>それか、分からないことを調べるのをグッと我慢して、ある程度読み進めてから目星う付けて調べるでもいいか。うまく緩急を付けるのがコツか。</p>
<h3 id="知っていた方がいいこと">知っていた方がいいこと</h3>
<ul>
<li>REPL &mdash; 対話型コンソールについては、ちょっとしたプログラムを動かすのに便利だ。</li>
<li>doctest</li>
</ul>
<p>あと、紙の本に落とす時にリンクは別にしてあるという方針なので、こうやって自分なりにそのlink集を再現した方が理解がしやすくなると思う。オンライン・ドキュメントを読んで理解が深まるなら作業は増えても、うんうん唸る時間は減る。</p>
<h4 id="用語集">用語集</h4>
<p>本文を読む前にざっとでいいから目を通しておくと、どの言葉が用語集にあるのか分かってよい。紙の文書だから、使っている用語をそのままハイパーリンクにできないのでこうしているのだと思うけど。</p>
<p>用語集が p711 からある。私のように用語の定義というか何を指しているのかを知りたがる人は先に目を通しておこう。 2020-07-12 の 06:10 時点で4章以前の疑問に思ったことはだいたい書いてある。最初から気がついていたら時間の節約もそうだし、悩む必要がなかった。</p>
<p>あと、本家の用語集(の日本語版)も目を通しておけとのこと。</p>
<ul>
<li><a href="https://docs.python.org/ja/3.7/glossary.html">用語集 — Python 3.7.8 ドキュメント</a></li>
</ul>
<h2 id="点検読書i">点検読書I</h2>
<h3 id="この本は何について書いたものであるか">「この本は何について書いたものであるか」</h3>
<p>(最後まで読み切れていないが、暫定版として)この本は、pythonの持っている力を引き出すメンタルモデルと、プログラミング方法について書いた本である。</p>
<h3 id="この本はどのように構成されているか">「この本はどのように構成されているか」</h3>
<p>まえがきのページ xii からの書いてある。拾い読みをするときに、いいガイドになるかも知れません。ただ、理解するには前に遡って読む必要があるかもしれません。</p>
<h4 id="i部">I部</h4>
<h4 id="ii部">II部</h4>
<h4 id="iii部">III部</h4>
<h4 id="iv部">IV部</h4>
<h4 id="v部">V部</h4>
<h4 id="vi部">VI部</h4>
<h3 id="どのような部分に分けられているか">「どのような部分に分けられているか」</h3>
<h3 id="この本はどういう種類の本か">「この本は、どういう種類の本か」</h3>
<p>pythonの能力を引き出す方法、pythonic? な方法について書いた本</p>
<h2 id="1章-pythonのデータモデル">1章 Pythonのデータモデル</h2>
<p>pythonのデータモデルについて説明なしに知っている前提で書いています。ひとまずいろいろ棚上げして、辛抱強く最後まで読むとなんとなく分かります。一緒に、<a href="https://docs.python.org/ja/3.7/reference/datamodel.html">3.データモデル</a>とか眺めておくといいかもしれません。</p>
<p>データモデルとは、何ぞやというのは、別の本でちゃんと定義されているのかもしれません。この章を読むと書いてある内容からなんとなく、「データモデル」とよんでいる物が、Pythonの根幹を為す、ダンダー<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>についての話なんだなって。</p>
<p>Soapbox の、「データモデル?それともオブジェクトモデル?」で、もう少しヒントがでてくる。</p>
<p>Soapboxでは、他にjsとjavaの話がでてる。p16からp17にかけて。</p>
<p>lenがメソッドでないのは、そうとう議論になったから何度も出てくるんだろうね。やはり。</p>
<h3 id="11-pythonicなトランプ">1.1 Pythonicなトランプ</h3>
<ul>
<li>
<p><a href="https://docs.python.org/ja/3.7/library/collections.html?highlight=namedtuple#collections.namedtuple">collections &mdash; コンテナデータ型 — Python 3.7.8 ドキュメント</a></p>
</li>
<li>
<p>2〜10,J,Q,K,Aの配列</p>
</li>
<li>
<p>namedtupleの利点は、固有のメソッドを持たないオブジェクトをのクラスを作れるようになった。以下は矢吹の推測だが、なんでもオブジェクトだとやりすぎで、シンプルなデータ構造を作ってメモリの有効活用をしたかったのではないか。</p>
</li>
</ul>
<dl>
<dt>シントピカル読書</dt>
<dd>Effective Pythonのp59で、namedtupleの限界というコラムがある。有用な場合と害の場合がある。とのこと。</dd>
</dl>
<h3 id="疑問点">疑問点</h3>
<ul>
<li>Pythonのデータモデルとは、どのように説明したらいいのか。</li>
</ul>
<h3 id="読書会で話題になったこと">読書会で、話題になったこと。</h3>
<p>chatに貼り付けてもらったとか、話題にでたのを主に書き残しておく。</p>
<ul>
<li>Python 入門ノート</li>
<li><a href="https://gihyo.jp/book/2020/978-4-297-11111-3">Python実践入門 ──言語の力を引き出し、開発効率を高める：書籍案内｜技術評論社</a></li>
<li><a href="https://paiza.io/en/projects/new?language=python3">Python Online | Online editor and compiler</a></li>
<li><a href="https://qiita.com/Seny/items/add4d03876f505442136">namedtupleで美しいpythonを書く！（翻訳） - Qiita</a>
<ul>
<li>namedtuple使いでがあるよね。って話</li>
</ul>
</li>
<li>DataClassも使いでがあるよね。いま読んでいるFluentPython日本語版は、主にpython3.3までの話題を取り扱っているので、DataClassの話はでてこないけど、discordのpythonコミュニティで話題になっていた。という話
<ul>
<li><a href="https://www.python.jp/pages/pythonjp_discord.html">Pythonjp Discord Server</a></li>
</ul>
</li>
<li>pylanceの話題。</li>
<li>用語集は先に読んでおくといいね。</li>
<li>使っているpythonの開発環境の話題。ice breakにはいいかもね。</li>
<li>Fluent Pythonのサンプルプログラムのライセンスは、MITであるとのこと。
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/LICENSE">example-code/LICENSE at master · fluentpython/example-code</a></li>
<li><a href="https://github.com/fluentpython/example-code">fluentpython/example-code: Example code for the book Fluent Python</a></li>
</ul>
</li>
<li><a href="https://github.com/fluentpython/example-code/blob/master/01-data-model/frenchdeck.py">example-code/frenchdeck.py at master · fluentpython/example-code</a></li>
<li><a href="https://github.com/fluentpython/example-code/blob/master/01-data-model/vector2d.py">example-code/vector2d.py at master · fluentpython/example-code</a></li>
</ul>
<h2 id="2章-シーケンスの配列">2章 シーケンスの配列</h2>
<p>pythonに関係深い、ABCという言語の話が導入となる。</p>
<p>シーケンスって、なんだったかな。と、Python ボケットリファレンスの113pを参照しておく。クラス図からの説明になる。きっちりと言葉で説明するのは難しいが、こうやってクラス図で表されると何となくわかる。でも他人に説明できるかと言われると多分できない。</p>
<p>データの入った物が一列に並んでいるイメージを想定してください。って感じか。コンテナが並んでいる感じ。</p>
<h3 id="21-組み込み型シーケンスの概要">2.1 組み込み型シーケンスの概要</h3>
<p>で、シーケンスとはなにか?については既知として、分類から概要が始まる。</p>
<ul>
<li>コンテナ・シーケンス</li>
<li>フラット・シーケンス</li>
</ul>
<p>p22を参照。参照が入るか、実体のデータたちがはいるか。それぞれに、メリットとデメリットがある。</p>
<p>別の分け方として、</p>
<ul>
<li>mutable sequence</li>
<li>immutable sequence</li>
</ul>
<p>可変なシーケンス、不変なシーケンスという日本語がわりあたっているが、昨今ではカタカナの方が通りがよかったりする?そして書き換えができるか、できないか。の違いなので、自分のイメージにひきつけて理解することにした。</p>
<p>そして、図2-1 この図に見慣れないと、後から混乱しそう。向かって右が、子で、向かって左が、親の関係か。ここでは子から親に矢印が向かっている。と理解した。p23</p>
<h3 id="22-リスト内包表記とジェネレータ式">2.2 リスト内包表記とジェネレータ式</h3>
<p>シーケンスを作る手段として、リスト内包表記と、ジェネレータ式に言及じている。「読みやすくて速い」という著者の主張を読み進めることになる。</p>
<p>下記は省略語として、</p>
<ul>
<li>listcomp : リスト内包表記</li>
<li>genexp : ジェネレータ式</li>
</ul>
<p>という表現を知る。</p>
<ul>
<li><a href="https://docs.python.org/ja/3.7/library/functions.html#ord">ord 組み込み関数 — Python 3.7.8 ドキュメント</a>
<ul>
<li>与えられたシンボルのコードを出力する。p24</li>
</ul>
</li>
</ul>
<p>p24の構文のヒントは役立った。ここで改行していいってのは、コードを見てなんとなくは分かっていたが文章で書いてもらえるのはありがたい。</p>
<p>p25のコラムは、python3の世界になったので、今となっては、python2のコードを書く必要がないかぎり忘れて良いのではないか。</p>
<h4 id="222-リスト内包表記とmapfilterの違い">2.2.2 リスト内包表記とmap/filterの違い</h4>
<p>pythonのlambdaか、機能的に足りないとは?　別の場所で言及はあるか。あと、何と比較して足りる足りないを著者は語っているのか。</p>
<p>例2-3のコードが、リスト内包表記とmap/filterで書いたコードを比較している。若干慣れの気がするかもしれないが、実行速度を比較するコード listcomp_speed.py があるので、差が分かるぐらいに違うんだろう。</p>
<h4 id="223-デカルト積">2.2.3 デカルト積</h4>
<p>デカルト積という名前に、不安を抱く必要は無い。数学の順列・組み合わせを思い出せば良いみたい。または行列の積</p>
<h4 id="224-ジェネレータ式">2.2.4 ジェネレータ式</h4>
<p>全部を一度に作らなくても、実行するたびに値を返せば、使用メモリーを減らすことができるのは道理だ。</p>
<p>あと、ポケットリファレンスでは、yield文を使う例しか出てこなかったが、ここでは違う書き方があるで勉強になる。</p>
<h4 id="231-レコードとしてのタプル">2.3.1 レコードとしてのタプル</h4>
<p>RDBをよく使っていると、レコードというと、RDBで処理したらいいじゃないか。と、してしまいそうになるが、ここで書いてあるテクニックは、pythonらしい書き方というか、データ操作方法になると思う。ある程度データが大きくなるまではRDBへの依存がないプログラムの方が扱いが楽だし。依存を増やすのは後からでもできる。</p>
<h4 id="232-タプルのアンパック">2.3.2 タプルのアンパック</h4>
<p>ここでの、アスタリスクの使い方は、おまじないだとして引数などに付けていた、アスタリスクが、vividに意味を持ち始めた。あとタプルの値のスワップに、一時変数を使わなくても良いってのは、C言語からすると楽ではあるが、ちょっと落ち着かない。(内部ではちゃんとしているだろうから便利に使わせてもらうのてはある)</p>
<p>_ は、文法でなく慣習であるというのは、前に調べていたのでよかった。また i18n への言及があるのは良い。ただ、これだけではない。p32</p>
<h4 id="233-ネストしたタプルのアンパック">2.3.3 ネストしたタプルのアンパック</h4>
<p>ちょっとしたRDBの問い合わせみたいなことをここでは、タプルとアンパックを使って実現してる。p33</p>
<h4 id="234-名前付きタプル">2.3.4 名前付きタプル</h4>
<p>僅かなメモリの増加を受け入れると、名前付きのタプルでこんな便利なことができるよ。と教えてくれる。プログラムをを書くにあたって確かに明確に意志を伝えるプログラムを書くことができるので使いたくなる。</p>
<p>本の範囲は外れるが、 python3.7からは、　<a href="https://docs.python.org/ja/3.7/library/dataclasses.html">dataclasses &mdash; データクラス — Python 3.7.8 ドキュメント</a> とかもあるのでデータを扱う引き出しが増えるので、ここにメモっておく。</p>
<h4 id="235-不変リストとしてのタプル">2.3.5 不変リストとしてのタプル</h4>
<p>不変リスト = immutable</p>
<p>listとtupleの似ている点について、どこまで一緒なのかを確認すると違う部分に集中できるので良さそう。p35からp36</p>
<h3 id="24-スライス">2.4 スライス</h3>
<p>ここで扱うのは、python本体と一緒に配布されているライブラリの使い方であり、自分で同じような動作をするクラスを作るのは、第10章で扱うとのこと。</p>
<p>ここでは、あんまりできると思っていなかった使い方を知る。ごちゃごちゃ書かずにスパッとデータを書き換える方法がある。p39</p>
<p>NumPyと、SciPyについては、例外として言及している。p38</p>
<h4 id="251-リストのリストの生成">2.5.1 リストのリストの生成</h4>
<p>ここは、実体を回数分生成しているのか、参照を回数分生成しているのか。を、必要な時には思い出したい。p41</p>
<h4 id="261-による代入の謎">2.6.1 +=による代入の謎</h4>
<p>へー。としか。確かにコーナーケースである。</p>
<ul>
<li>
<p><a href="http://www.pythontutor.com/live.html#code=t%20%3D%20%281,2,%20%5B30,40%5D%29%0At%5B2%5D%20%2B%3D%20%5B50,60%5D%0A&amp;cumulative=true&amp;curInstr=2&amp;heapPrimitives=true&amp;mode=display&amp;origin=opt-live.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">python tutor</a></p>
<ul>
<li>pythonのlive programmingモードにしておく。</li>
</ul>
</li>
<li>
<p>byte codeを吐き出すのに、 <a href="https://docs.python.org/ja/3/library/dis.html">dis &mdash; Python バイトコードの逆アセンブラ — Python 3.8.4rc1 ドキュメント</a> を参照すること。<code>import dis</code>をしないとエラーになる。</p>
</li>
</ul>
<h3 id="27-listsortと組み込み関数-sorted">2.7 list.sortと組み込み関数 sorted</h3>
<p>Noneが返ると、chain methodにならない。逆説的に、chain methodを作る方法とするのがいいか。p45</p>
<h3 id="28-bisectを使った順序付きシーケンスの処理">2.8 bisectを使った順序付きシーケンスの処理</h3>
<p>大量のデータから、できるだけ速く該当のデータを探し出すために、あるキー順にソートしてある前提でデーさ操作をすることがある。</p>
<p>身近な例でいうと、git bisect がキーワードとして似ているし、二分木探索の話はどのアルゴリズムの本なら触れているだろう。これまで読んだ本でおもしろかったのは、debugに、2分木法を使うという本を読んだときであった。</p>
<h3 id="29-listを使わない方がよいケース">2.9 listを使わない方がよいケース</h3>
<p>こいつ使って、いつ使わないかも知りたかった、</p>
<h4 id="291-配列">2.9.1 配列</h4>
<p>ここも読む価値がある。</p>
<h4 id="292-メモリービュー">2.9.2 メモリービュー</h4>
<p>Cのstructとunionの合わせ技みたいなことができるんや。</p>
<p>例 2-21に対するメモ</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">% <span class="nb">echo</span> <span class="s2">&#34;obase=16;ibase=10;1024&#34;</span><span class="p">|</span>bc
<span class="m">400</span>
</code></pre></div><h4 id="293-numpyとscipy">2.9.3 NumPyとSciPy</h4>
<p>この本では、基本的にはPythonに付属のライブラリの話をしているが、ここではタイトルの用に、NumPyとSciPyを扱う。</p>
<p>私は、Debian GNU/Linuxを使っており、お手軽に導入するため、<code>apt install python3-numpy python3-scipy</code>のコマンドで導入した。</p>
<h4 id="294-デックやその他のキュー">2.9.4 デックやその他のキュー</h4>
<p>appendやpopメソッドを使えば、スタックやキューとして使えるし、inque,dequeについても書いてある。スレッドセーフなのが嬉しい。</p>
<p>ここも、スレッドセーフ、プロセス間通信、asyncioに対応した。queue関係の情報かある。そしてheapqがあるので一から作らなくても、シーケンスをヒープキューや優先順序付きのキューを提供してくれるとのことで、自分で書いてデバッグする時間を減らすことができそう。</p>
<h3 id="210-本章のまとめ">2.10 本章のまとめ</h3>
<p>一度読んでおけば、ここから情報を取るだけで思い出せることが増えて良さそう。p61-p62</p>
<h3 id="211-参考文献">2.11 参考文献</h3>
<p>ここは、また戻ってきた時に参照する。一回目は軽くなぞるだけにする。</p>
<p>Soapboxの「すばらしいkey」については、心惹かれた。</p>
<h2 id="3章-ディクショナリとセット">3章 ディクショナリとセット</h2>
<p>この章は、最初に概要を書いてくれている。良い。</p>
<p>pythonを使っていて、辞書(ディクショナリ/dict)型を使わないことはない。と言いきってもいいぐらい。ユーザーが作っているプログラムで多用されているだけでなく、</p>
<ul>
<li>モジュールの名前空間</li>
<li>クラスとインスタンスの属性</li>
<li>関数のキーワード引数</li>
</ul>
<p>などのpythonを支えている機能は、dict型で実装されている。これらはハッシュテーブル
で作られていることが明かされる。</p>
<p>この章では、ハッシュテーブルの仕組みを解説することで、pythonのdictとsetを活用する方法を学ぶことができるとある。</p>
<h3 id="31-一般的なマップ型">3.1 一般的なマップ型</h3>
<p>map型とは一体 :thinking face: なりながら、読み進める。</p>
<ul>
<li>
<p><a href="https://docs.python.org/ja/3.7/library/collections.html">collections &mdash; コンテナデータ型 — Python 3.7.8 ドキュメント</a></p>
<ul>
<li>話は逸れるが、このへんは見ておこう。</li>
</ul>
</li>
<li>
<p><a href="https://docs.python.org/ja/3.7/library/collections.abc.html#module-collections.abc">collections.abc &mdash; コレクションの抽象基底クラス — Python 3.7.8 ドキュメント</a></p>
<ul>
<li>本命はこっち、以前は上記と一緒だったが、python3.3で分かれた。</li>
</ul>
</li>
</ul>
<p>p70の図3-1</p>
<p>Mappingと、MutableMappingの継承について書いてあるから、これがmap型の説明なんだと思う。言葉でなく、UML図で示す感じ。どういうメンバーというかメソッドがいるのか、ってのを理解するのはこっちの方がまどろっこしくないからいいのか。</p>
<p>特殊用途のマップの実装について、ここに記述がある。「抽象基底クラス」ではなく、dictまたは、collections.UserDictを拡張することについて書いてある。</p>
<p>dict型かどうかを検査するより、isinstanceを用いよ。という話</p>
<p>「ハッシュ可能とは」というコラムはp70からp71 オブジェクト比較の話だが、比較できない場合について述べてあるので、いつ使えて、いつ使えないのかを確認するために参照することになるかも。内部状態という概念は得た。</p>
<ul>
<li><a href="https://docs.python.org/ja/3.7/library/stdtypes.html#mapping-types-dict">組み込み型 — Python 3.7.8 ドキュメント</a>
<ul>
<li>文書の中で言及しているは、この部分である。</li>
<li>ここの文書も一階層あがって読みきったから、この本書いているんだろうな。</li>
<li>日本語版をpointしているので、4. Built-in Typesかどうかは見てない。例が同じそうだ。というのは軽く確認した。</li>
</ul>
</li>
</ul>
<h3 id="32-ディクショナリ内包表記">3.2 ディクショナリ内包表記</h3>
<p>リスト内包表記があるなら、ディクショナリも同じような書き方ができると類推できるよね。ってことか。p72</p>
<h3 id="一般的なマップメソッドの概要">一般的なマップメソッドの概要</h3>
<p>ここでも出てくるAPIという言葉。メソッドと何が違うのか、最初で定義しているのに読み飛ばしたかなと思えてきた。</p>
<p>ここの表も必要があれば参照したくなるだろう。dict,defaultdict,OrderedDictの差がわかる。</p>
<h3 id="331-存在しないキーをsetdefaultで処理">3.3.1 存在しないキーをsetdefaultで処理</h3>
<p>ここで、「フェールファースト」の理念が出てくる。私はあんまり聞いたことがなかったので、監訳者の注で意味が補われていて予想した意味と異なっておらず助かった。ダックタイピングはけっこう聞くのでそこは気にならず。</p>
<p>この、setdefaultに関しては、持っているPythonポケットリファレンスの、P154 「9-3-8 デフォルト値付きの抽出」で、大まかな内容を知っているので、細かく挙動を書いてあるぽいことだけ確認した。</p>
<p>p75-o75 まずは、setdefaultを使わない方法を示して、p76で、setdefaultを使って解きなおししている。</p>
<h3 id="34-柔軟なキー検索を使ったマップ">3.4 柔軟なキー検索を使ったマップ</h3>
<p>サーチしたキーが、存在しなかった時に、どういう扱いがいいかについて、2つの方法を提示している。</p>
<ol>
<li>dictの代わりに、defautldictを使う</li>
<li>サブクラスを作って、__missing__ メソッドを追加する。</li>
</ol>
<h4 id="341-defaultdict-----存在しないキーの扱い方-その1">3.4.1 defaultdict &mdash; 存在しないキーの扱い方 その1</h4>
<p>ここでは、サーチして最初に見つかったときに、エントリーを生成するプログラムを例として説明している。ようするに、KeyErrorを発生させない。</p>
<p>p78 のいつ呼び出されて、どういうときに呼び出されないか。は押さえておきたい。</p>
<h4 id="342-__missing__-メソッド-----存在しないキーの扱い方-その2">3.4.2 __missing__ メソッド &mdash; 存在しないキーの扱い方 その2</h4>
<p>__missing__ の定義の方法と、どのタイミングで、呼び出されるのかについて記述してある。これ、pythonの基礎的なメカニズムなんで、後から広く応用できるんではないだろうか。rubyのmissing_methodのように。読み進めると分かるか。</p>
<p>これについても、何時使えて、いつ使えないのか書いてあるので、ここは後からも参照しそうな感じ。p78</p>
<p>__missing__ の実装で、isinstance のチェックが必要な理由についても読んでおきたい。</p>
<h3 id="35-dictのバリエーション">3.5 dictのバリエーション</h3>
<ul>
<li>collections.OrderedDictの説明 p81
<ul>
<li>挿入された順、デフォルトはqueueのような動作だが、stackのような動作をさせることもできる。</li>
</ul>
</li>
<li>collections.ChainMap の説明 p81
<ul>
<li>複数のマップを一括でサーチできる。サクッと作って後からチューニングするのに便利そう。どう使うかの例は書いてある。</li>
</ul>
</li>
<li>collections.Counter の説明 p82
<ul>
<li>最頻をカウントするのに便利そう。いくつか便利そうなメソッドも紹介している。</li>
</ul>
</li>
<li>collectgions.UserDict
<ul>
<li>次の 3.6 で説明とのこと。</li>
</ul>
</li>
</ul>
<h3 id="36-userdictのサブクラス化">3.6 UserDictのサブクラス化</h3>
<p>こっちを使う方が便利なんじゃないかなっていう指針を教えてくれる。UserDicTを使う前には、読んでおくとハマらずに短い時間でプログラムを作れそう。</p>
<h3 id="37-不変マップ">3.7 不変マップ</h3>
<p>immutable map 何時使うのか。についてはアイディアや必要性に迫られた時でいいか。その時に細かく読めば良いか。</p>
<h3 id="38-セット">3.8 セット</h3>
<p>ポケットリファレンスのP155からp156にざっくりと書いてあるのを復習してからこの 3.8 を読む。</p>
<p>setについて。記述が古いのかあんまり使われていないとあるが、ハマると便利なんで使いこなしたい。classとしての、setとfrozenset</p>
<ul>
<li>重複した要素を許さない。
<ul>
<li>これは、RDBの一意制約にも似て、使いでがある制約に感じる。</li>
<li>本文中の「重複する要素を削除することが」<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>ってのは、結果としてそうなる。という意味に取らないと削除する動作を何時するんだってなりそう。</li>
</ul>
</li>
<li>Setの要素は、ハッシュ可能であること。Set自体はハッシュ不可能、Frozensetはハッシュ可能なので、Setの要素に、Set自身は使えないが、Froaensetは使える。</li>
<li>このへんになってくると、数学の集合論を利用したくなるね。集合論的な操作できるし。ループや条件分岐を減らせるのは、コードが短くなって間違いの余地が減りそう。</li>
</ul>
<h4 id="381-リテラル">3.8.1 リテラル</h4>
<p>Setの構文で、だいたい数学と一緒なんだけど、空集合だけは別の書き方をするぜ。{}とかくと、意図に反して空のdictができてしまう。これって、間違えないようにする工夫はあるだろうか。型?</p>
<p>リテラルなset構文は、慣れれば意図は明解なので良いという主張。コンストラクターを使う呼び出し方法と、リテラルの処理で、BUILD_SETバイトコードの実行の話になる。p87</p>
<p>バイトコードのdisアセンブラを見せながらの解説をしてくれる。</p>
<p>Frozensetには、リテラル表記はない。のでコンストラクタを呼び出すしかないとのこと。</p>
<h4 id="382-セット内包表記">3.8.2 セット内包表記</h4>
<p>をを、確かにセットも内包表記があってしかるべきだよな。p88</p>
<h4 id="383-セットの演算">3.8,3 セットの演算</h4>
<p>ここで出てくる、「インプレイスで変更/更新」ってあんまり聞かない表現なんだけど。p88</p>
<p>ここで出てくるsetの操作をうまく使うとコードを短くできそう。</p>
<h3 id="39-dictとsetの内部構造">3.9 dictとsetの内部構造</h3>
<p>内部構造の話だから、読み飛ばそうかなって思ったんだけど、性能やトレードオフの問題が書いてあるので、読み飛ばせなかった。ある程度経験を積んだプログラマなら気になることが書いてある。</p>
<p>この節では、</p>
<ul>
<li>Pythonのdictとsetはどれだけ効率的なのか。</li>
<li>なぜ順序付きではないのか。</li>
<li>任意のPythonオブジェクトをdictのキーまたは、setの要素に使えないのはなぜなのか。</li>
<li>dictのキーやsetの要素の順序が、挿入順に依存し、その構造が利用している間に変化することもあるのはどうしてなのか</li>
<li>dictやsetに対してイテレーションを行っているとき、それらに要素を追加してはいけないのはなぜなのか</li>
</ul>
<p>を、説明してくれる。とのこと。内部構造を知ることで、その得失点と(pythonの)低レイヤを意識することで、性能と仕様を満たすバランスを考えることになるんだろうな。という感じか。メモを書きながら読んでいるので、後で訂正するかも。</p>
<h4 id="391-性能評価実験">3.9.1 性能評価実験</h4>
<p>じぶんのpython3の環境で、追試してみるのも良いが、いまではない。</p>
<h4 id="392-ディクショナリのハッシュテーブル">3.9.2 ディクショナリのハッシュテーブル</h4>
<h4 id="393-dictの構造に起因する実用上の影響">3.9.3 dictの構造に起因する実用上の影響</h4>
<p>ここは一読しただけでは、よく分からない。将来のためにメモだけ残しておく。</p>
<ul>
<li>p97 「ユーザ定義型のハッシュ値は、id()であり、それらを比較した結果はいつも等しくないため、元からハッシュ可能です。」って、「キーはハッシュ可能なオブジェクトでならなくてはいけない」とぱっと見に反しているので、補足が欲しい気がする。
<ul>
<li>等しいということは、「ハッシュが同じ」である。__eq__() を実装する時に注意が必要っぽい。</li>
</ul>
</li>
<li>dictには顕著なメモリーオーバーヘッドがある。
<ul>
<li>ここは重要で、どうしたら良いのかの提案もある。ただし書いてあるように、早すぎた最適化は保守性を下げるので、手早く富豪的アプローチで作ってから最適化を考えるというのも動かさないと評価できないので、一つの知見でもあろう。</li>
</ul>
</li>
<li>キーサーチは非常に高速ってのは、スペースと時間がトレードオフになっている。アクセス時間はサイズに関係ない。サイズを指数的に大きくしても、影響はすくない。
<ul>
<li>ちゅうことは、この辺が実用的なpythonのプログラムを作るに当たっての勘どころなのか?</li>
</ul>
</li>
<li>dictに要素を追加するとキーの既存の順序が変更される可能性がある
<ul>
<li>これ知っておかないとハマるだろう。既存と更新用に分けたら良いだけ。富豪的アプローチだけど副作用を考えたらね。こんな感じで困るぐらいカツカツの環境なら、言語とか仕様とか考え直して実装したほうがいいんじゃないだろうか。まずはpythonでつくって仮説を検証するでかなりの所までいけるでしょう。</li>
</ul>
</li>
</ul>
<h4 id="394-セットの挙動">3.9.4 セットの挙動</h4>
<p>これまで記述してある内容の重複をさけるためにあっさりとしているが、これもsetを使う上では勘案することである。p99-p100</p>
<h3 id="310-本章のまとめ">3.10 本章のまとめ</h3>
<p>ここも、一度通読してから、読み直して頭に定着させるためにいい感じ。</p>
<h3 id="311-参考文献">3.11 参考文献</h3>
<p>あとでリンク貼る。</p>
<p>ここのSoapbox p101-p102 は、いまいち理解できず。ハッシュの機構がシンプルだというのは、同意できるが、正確だというのは、何に対してどう正確なのか、理解できてない。他の言語の記述方法に似ていることと正確さに何の関連があるのか。正確というのは何かの基準があってそこへの差分が一定範囲内だという理解なので、いまいちピンときていないのだと思う。</p>
<h2 id="4章-テキストとバイト">4章 テキストとバイト</h2>
<p>ここは、どのぐらいの事前知識を必要とするのだろうか。Unicodeのの時代だし、CJKに深く突っ込む所でもないから、文字コード本みたいな副読本はいらないかもしれない。とか思ったが、そんなことなさそう。Unidodeのバージョンの話がでてくるから、制定の話と改訂の話ぐらいは知っておくのは、この本を読む前に知っとけということ。</p>
<p>文字とバイトを区別するという話なので、まずは読み進めてみる。下記のトピックについて解説するとある。</p>
<ul>
<li>文字、コードポイント、およびバイト表現</li>
<li>bytes, bytearrary,memoryviewといったバイナリーシーケンス固有の機能</li>
<li>Unicodeおよび従来型の文字セットの完全なコーデック</li>
<li>エンコーディングエラーの回避と処置</li>
<li>テキストファイル処理におけるベストプラクティス</li>
<li>デフォルトエンコーディングと標準入出力の問題</li>
<li>正規化による安全なUnicodeテキストの比較</li>
<li>正規化、ケースフォールディング、付加記号を強引に除去するユーティリティ関数</li>
<li>localeとPyUCAライブラリを用いたUnicodeテキストの的確なソート</li>
<li>文字とメタデータを収録したUnicodeデータベース</li>
<li>strとbytesを処理するデュアルモードAPI</li>
</ul>
<p>はい。もうこの段階で、Codecが具体的に何を指しているのか、とか、Unicodeの正規化について具体的なイメージが沸かないので中身を読み進めたくなってきました。
ケースフォールディングに関しては、監訳者の注があるので意味が分かりました。MySQLとかでも問題になっていた件をpythonでどう解決するではないかと思いましたが、当たっているかどうかは読み進めてみないと分かりません。最初印象ってか予期しているバイアスを書いておいて後から自分で修正するスタイルで。</p>
<h3 id="41-文字の問題">4.1 文字の問題</h3>
<p>Unicodeをpythonで扱ってみて、皆さん慣れてくださいね。のパートです。</p>
<p>もうpython3に移行していると思うので、python2の記述は過去の資産をメンテする必要がなければ、読み飛ばしていきます。</p>
<h3 id="42-バイトについて">4.2 バイトについて</h3>
<p>C言語をやったことがあれば、unsigned charとか、unsigned char * で操作してる感じよね。って感じの話っぽい。低レベルな技術者<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>なら、するすると読み下せそう。</p>
<p>ここで出てくる、encodeとdecodeの例えは、図があったほうがいいな。本に落書きするか。</p>
<h4 id="421-structとメモリビュー">4.2.1 structとメモリビュー</h4>
<p>これ、まんまC言語のstructで型にハメるやりかたや。memoryviewでunionってか参照させる感じなんや。こんな低レイヤなことできるんだな。</p>
<h3 id="43-基本的なエンコーダとデコーダ">4.3 基本的なエンコーダとデコーダ</h3>
<p>エンコーダとデコーダの両方を指す言葉として、コーデックと呼んでいるのがここに来てわかった。</p>
<p>参考になるが、CJKの本ではないので、日本語を扱うのであれば、Linux上でつかっているし、utf-8一択だな。発展的に調べるとCP932とかも多分あるんだろうけど。</p>
<p>サロゲートペアの説明をp111でしているのは良い。</p>
<h3 id="44-エンコードとデコードの問題点">4.4 エンコードとデコードの問題点</h3>
<p>以下で個別に、エラーへの対処策が書いてあるので、困ったときにはそこを読めば良いってのは、困っている人向けに書いているからだろうな。</p>
<h4 id="441-unicodeencodeerrorへの対処策">4.4.1 UnicodeEncodeErrorへの対処策</h4>
<p>P112-p112</p>
<h4 id="442-unicodedecodeerrorへの対処策">4.4.2 UnicodeDecodeerrorへの対処策</h4>
<p>p113-p114</p>
<h4 id="443-予期しないエンコーディングでモジュールをロードしたときのsyntaxerror">4.4.3 予期しないエンコーディングでモジュールをロードしたときのSyntaxError</h4>
<p>p114-p115</p>
<p>コラムの「ソースコードでASCII文字でない名前を使ってよいものでしょうか」はおもしろい
が使っていいときと使ってよくない時があるし、思っている以上に使われる可能性があるなら
やめとけなんだろうね。</p>
<h4 id="444-バイトシーケンスのエンコーディングを知る方法">4.4.4 バイトシーケンスのエンコーディングを知る方法</h4>
<p>そりゃそうだろうな。知っている所から(生成側)から教えないと正確な所は分かるまい。できても推測までで、身近な例だとブラウザがやっている。長い文字列なら判別できるが、短いと文字化けした経験はあるだろう。</p>
<h4 id="445-便利だけど厄介なbom">4.4.5 便利だけど厄介なBOM</h4>
<p>UTF16エンコードのBOMの話です。GNU/LinuxならUTF8で幸せなんだけど。P117-P118</p>
<h3 id="45-テキストファイルの処理">4.5 テキストファイルの処理</h3>
<p>GNU/Linux環境なら、デフォルトがUTF8なのでこれに悩むことはないが、他のエンコードをもつシステムとデータのやりとりをする必要があるなら読んでおこう。ネット上にも記事はあるが、せっかく買ってあるのだから読めば良い。P118-P121</p>
<h4 id="451-大混乱なデフォルトエンコーディング">4.5.1 大混乱なデフォルトエンコーディング</h4>
<p>使っているOSで、どういう風にデフォルトエンコーディングになっているかの説明をしている。確認方法を提供しているので、混乱したらここから調査を開始するのもいいかと。P121-P124</p>
<h3 id="46-適切な比較のためのunicodeの正規化">4.6 適切な比較のためのUnicodeの正規化</h3>
<p>ソートを含めて文字の大小比較をどうするかについて。アクセント記号の話題だったりするが、日本語でもまったく関係ないわけでもない。うに濁点とか。絵文字とか。は本書で取り上げていないけど関係ある。あと検索時にアクセント記号をつけていなくても付けているの同じように検索したいとかありそうな仕様ですし。日本語だとカタカナだろうがひらかなだろうが、同一視したいとか。と考えたらいいのかな。</p>
<p>本文例だと、1/2を3文字のASCIIで入力してもUnicodeの一文字1/2を同一視することを書いている。</p>
<p>監訳者注で、NFC,NFD,NFKC,NFKDについて略していない用語をだしている。これらの意味を知りたいならUnicode本が必要っぽい。この辺書いた本があれば後でここに書き足そう。文字コードの本は何冊かあるはず。オンラインで検索してもいいけども</p>
<p>P124-P127</p>
<h4 id="461-ケースフォールディング">4.6.1 ケースフォールディング</h4>
<p>基本的には、すべての文字列を小文字に変換することなのか。例外もある。が本文を参照してほしい。p127</p>
<h4 id="462-テキストを正規化してから比較するユーティリティ関数">4.6.2 テキストを正規化してから比較するユーティリティ関数</h4>
<p>NFCとNFDが出てくるが、p125 で用語の説明がしてある。</p>
<h4 id="463-付加記号う取り除く極端な正規表現">4.6.3 付加記号う取り除く極端な正規表現</h4>
<p>著者としては、力のはいっている部分なんだろうと思う。でも日本語話者としては、もっと身近な例がいいな。</p>
<p>p128-o133</p>
<h3 id="47-unicodeテキストのソート">4.7 Unicodeテキストのソート</h3>
<p>localeに応じてソート。GNU/Linuxなら充分に動くが、&hellip;</p>
<h4 id="471-unicode照合アルゴリズムでソート">4.7.1 Unicode照合アルゴリズムでソート</h4>
<p>ここで、PyUCAが出てくる。localeは見ずに、結果をカスタマイズすることができる。GNU/Linux以外の人には朗報だね。p135</p>
<h3 id="48-unicodeデータベース">4.8 Unicodeデータベース</h3>
<ul>
<li><a href="https://docs.python.org/ja/3.7/howto/unicode.html">Unicode HOWTO — Python 3.7.8 ドキュメント</a>
<ul>
<li>これも副読文書としてリンクしておこう。</li>
</ul>
</li>
<li><a href="https://docs.python.org/ja/3.7/library/unicodedata.html">unicodedata &mdash; Unicode データベース — Python 3.7.8 ドキュメント</a></li>
</ul>
<p>正規表現については、いまでもPyPIの方が優れているのだろうか。新しいバージョンで更新されているのかとか確認する方法は、簡単に分かったりしないのだろうか。開発を追っかけるのが堅い手ではあるのだけども。</p>
<h3 id="49-strbytes-デュアルモードapi">4.9 str/bytes デュアルモードAPI</h3>
<h4 id="491-正規表現におけるstrとbytes">4.9.1 正規表現におけるstrとbytes</h4>
<p>具体例がでてくる。</p>
<p>CJKのってか、日本語の場合は??</p>
<h4 id="492-osモジュールにおけるstrとbytes">4.9.2 OSモジュールにおけるstrとbytes</h4>
<p>GNU/Linux上での説明に始まり、他のプラットホームはそこそこ。</p>
<p>この扱いをみていると、一番便利なのはGNU/Linux上でUTF8で使うことで、私はそのど真ん中の例なんだな。</p>
<h3 id="410-本書のまとめ">4.10 本書のまとめ</h3>
<p>これ理解するのは、本当に大変で、資料を読んで、自分の卑近て例だけでわかった気になるとヤバいやつだというのはわかった。GNU/Linux上で、Pythonを使っている幸せを感じてポーティングするより windowsとかでもwsl2もあることだし、そっちで何とかしてくれと言うのが良さそう。もうUTF8で幸せになろうよ。ってのが私の感想です。</p>
<h2 id="5章-第一級関数">5章 第一級関数</h2>
<p>最初に、Guidoが、関数型言語から影響を受けたとは思っていないという引用から始まる。しかしこれを明言しない理由は何だったんだろうか。</p>
<p>2020-07-12 06:47</p>
<p>第一級関数=第一級オブジェクトの定義を読んでいて、気になることがある。</p>
<ul>
<li>ランタイムに生成できる。</li>
<li>データ構造の中の変数や要素に代入できる</li>
<li>関数の引数として渡すことができる</li>
<li>関数の結果として返すことができる</li>
</ul>
<p>で、最初のランタイム<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>に生成できる。というのに違和感がある。ランタイムは、実行バイナリのことを指してランタイムということがある。が、pythonの場合コンバイラとしてバイナリを吐き出すのが、いつでも成り立つ訳ではない。実行している時にとか、プログラムを実行している間にとか、そういう意味ではないのか。</p>
<p>関数が第一オブジェクトでない言語って、BASICとかかな。最近の言語だと可能なのが多いので分からんようになるわ。</p>
<h3 id="51-関数をオブジェクトのように扱う">5.1 関数をオブジェクトのように扱う</h3>
<p>実例をだしている。</p>
<h3 id="52-高階関数">5.2 高階関数</h3>
<p>ここでの高階関数の定義は、「関数を引数として受け取ったり、結果として関数を返したりする関数」とのこと。この定義は、ボケットリファレンスのp268にある 「16-1-3 高階関数を使う」においても同じ内容であった。</p>
<h4 id="521-mapfilterreduceの最新の代替">5.2.1 map,filter,reduceの最新の代替</h4>
<p>もう、python2は考慮しなくてよいものとして読むスピードを上げる。</p>
<p>map,filter,reduceよりも、リスト内包表記やジェネレータ式で代替できるので、使われなくなった。というのは、なるほどと思った。パイソン風(pythonic)なプログラミングでは、そう書くのだと。例5-5でmapをリスト内包表記に書き換えている実例を出している。</p>
<p>例 5-6 で、reduceを使う典型例として、合計値を求めるのに、sumを使う例を出している。</p>
<p>mapとfiltgerは、ジェネレータを返すので、その扱いを変えるのが良いという話である。これも使う関数を真似るのではなく、使っている真意をマネよってことで。読んでよかったなと。</p>
<p>一つの値というか結果に「集約」するというのが、キモだということ。</p>
<p>あとの10.5や、14.11 でのイテラブルについても言及すると先触れを出していている。</p>
<p>ちなみに、ポケットリファレンスでは該当するページはp269-p271であるが、ここの部分の学びについては書いていないので、自分で追記しておく。</p>
<h3 id="53-無名関数">5.3 無名関数</h3>
<p>lambdaの話。</p>
<p>いつ使えが明解でよい。</p>
<p>頑張りすぎて、わかりににくいlambdaを除去するリファクタリングレシピもいい。p154</p>
<ul>
<li><a href="https://docs.python.org/ja/3.7/howto/functional.html">関数型プログラミング HOWTO — Python 3.7.8 ドキュメント</a>
<ul>
<li>これは、Fluent Pythonが勧めているリンクである。そして、このhowtoが公式に取り込まれているのも、最初のGuido氏の言葉の引用はいったい。著者の冗談と取るべきなのか。それとも?</li>
</ul>
</li>
</ul>
<h3 id="54-7つの呼び出し可能オブジェクト">5.4 7つの呼び出し可能オブジェクト</h3>
<p>呼び出しオブジェクトについて、列挙し、コメントをして理解しやすくしてくれている。後のために、ジェネレータ関数の所で、コルーチンについて言及している。また呼び出し可能か判定するのは、そのオブジェクトのcallable()を呼んでみる。のを実例を入れて書いている。p154-p156</p>
<h3 id="55-呼び出し可能なユーザ定義型">5.5 呼び出し可能なユーザ定義型</h3>
<p><a href="https://github.com/fluentpython/example-code/blob/master/05-1class-func/bingocall.py">example-code/bingocall.py at master · fluentpython/example-code</a>
- インスタンス化する時にクラスを実行する
- インスタンス化したオブジェクトを実行すると、 __call__(self):を定義してどんな戻り値にするか決めることができる。</p>
<dl>
<dt>疑問点</dt>
<dd>p157で書いてある、クラスに、 __call__ を実装すれば、の下りは、ここで何を言っているのか意味がよく分からない。他の人とも議論してみたい。</dd>
</dl>
<h3 id="56-関数のイントロスペクション">5.6 関数のイントロスペクション</h3>
<h3 id="510-関数型プログラミングのためのパッケージ">5.10 関数型プログラミングのためのパッケージ</h3>
<p>純粋な関数型プログラミングう行うというよりも、lru|cache などのデコレータを便利に使うための手段して関数型を取り込んでいるというのが、後から読み直した時の所感です。便利に使うためにはA事前に学んでおかないといけないので、後で効いてくる。</p>
<h2 id="6章-第1級関数を使ったデザインバターン">6章 第1級関数を使ったデザインバターン</h2>
<p>see also オライリーの実践python3の方が、デザインパターンについて詳しいのであるが、本書では、Strategry のパターンについて繰り返しpythonの異なる機能を用いて紹介している。</p>
<h3 id="61-リファクタリングのケーススタディとしての-strategy-パターン">6.1 リファクタリングのケーススタディとしての Strategy パターン</h3>
<h4 id="611-典型的な-strategy-パターン">6.1.1 典型的な Strategy パターン</h4>
<p>抽象基底クラス(ABC) として使うために、@abstractmethodデコレータを使っている。7章を読んだ後だと、やはりpythonは、デコレータの使いこなさないといけない。</p>
<h4 id="612-関数指向の-strategy-パターン">6.1.2 関数指向の Strategy パターン</h4>
<h4 id="613-シンプルな方法による最良の-strategy-の選択">6.1.3 シンプルな方法による最良の Strategy の選択</h4>
<p>気をつける点について、解決方法を下記で解決策を提示している。</p>
<h4 id="614-モジュールにある-strategy-を検索">6.1.4 モジュールにある Strategy を検索</h4>
<ul>
<li>globals()を使って関数を見つける</li>
<li>イントロスペクションを使う</li>
</ul>
<p>詳細は、本書のp186-p187を参照せよ。</p>
<h3 id="command-パターン">Command パターン</h3>
<p>図6-2 p188のUML図</p>
<p>実行するコマンドのリストを生成する、より高度なundoを実装するためのヒントを提案してくれている。 __call__ メソッドをわかってからここにくる必要がある。</p>
<h3 id="63-本章のまとめ">6.3 本章のまとめ</h3>
<p>Design Pattern は、金科玉条でなく、言語の特性を応じて、コードの書き方でなくアイデアを活かして実装する話である。なので、他言語で慣れていても、pythonらしい書き方をする。(Fluent python)にあてはめ、こういう風にするのだ。ということを著者は言いたかったのだろうな。と思いながら読んだ。</p>
<h3 id="64-参考文献">6.4 参考文献</h3>
<p>Soapboxで、7章に、Visitorパターンを作るときに、有用であるという、ジェネリック関数を予告している。また、CLOSのマルチメソッド<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>など予告しており、脳内の関連情報を読者に伝えたい意図を感じた。</p>
<h2 id="7章-関数デコレータとクロージャ">7章 関数デコレータとクロージャ</h2>
<p>デコレータを使いこなすためには、クロージャの理解が必要とのこと。</p>
<p>p194にある。</p>
<ul>
<li>Pythonのデコレータ構文の評価方法</li>
<li>変数がローカルであるかを Python が判断する方法</li>
<li>クロージャの存在意義とその挙動
nonlocalで解決できる問題</li>
</ul>
<p>上記の説明をこの章で受けて、クロージャの挙動がよくわかったので、とても良かった。python ポケットリファレンスでは、端的に説明されていて、理解できていなかった。これは、ボケットリファレンスなので、この様な概念をキチンと説明するのは荷が重いのは理解するが、重要な概念だけに省くことはできなかったのだろうな。とも思う。プログラミング経験者が、pythonの教科書を購入するなら、ここは一つ内容を確認しておくのがいいのではないか。と私は思う。もちろん、もう理解しているから要らないと意見もあるかもしれない。</p>
<dl>
<dt>コーディングを支える技術</dt>
<dd>別の本、「コーディングを支える技術」で、オブジェクト指向の話がでてくる。そこで、「11.2 変数と関数を束ねて模型を作る方法」p190がある。ある目的を達成するために、3つの方法がある。と書いている。(1)モジュール &mdash; Perlで使われている関数を束ねておくパッケージと、変数を束ねておくためのハッシュを結びつけておく方法(2) 関数も変数もハッシュに入れてしまう。JavaScriptなどが採用している方法(3)クロージャという主に関数型言語で使われている関数実行時の名前空間を変数をまとめるために使う方法です。と書いている。<!-- raw HTML omitted -->それぞれ詳しくは、本を参照して欲しいが、クロージャの説明として「11.5 方法3:クロージャ」P206があるが、実は、その前の「11.4 方法2:関数もハッシュに入れる」も読んでおかないと、fluent pythonで書いてあることに関係するからです。「ファーストクラス」「関数をハッシュに入れる」など。<!-- raw HTML omitted -->ここのクロージャの説明は、javascriptを例にしているので、pythonを学ぶ目的であれば、fluent pythonの方が良いだろう。「自由変数」というキーワードは「コーディングを支える技術」でも、でてきた。クロージャがなぜ「閉じる」という話になるのか。という概念になるのか。</dd>
</dl>
<h3 id="71-デコレータの基礎">7.1 デコレータの基礎</h3>
<p>どういう動作をするか。についてのチュートリアル。</p>
<h3 id="72-デコレータ実行のタイミング">7.2 デコレータ実行のタイミング</h3>
<p>ここのキモは、デコレータの実行タイミングを書いており、インポート時に何が起きているのか。を書いている所です。たしかに、そういう風に動くにはこのタイミングか。というのは理解できる。</p>
<h3 id="73-デコレータを使った-strategy-パターンの改善">7.3 デコレータを使った Strategy パターンの改善</h3>
<p>例7-3は、<a href="https://github.com/fluentpython/example-code/blob/master/07-closure-deco/strategy_best4.py">example-code/strategy_best4.py at master · fluentpython/example-code</a> が該当する</p>
<p>動いているコードで、理解を深めるのがいい。</p>
<h3 id="74-変数スコープ">7.4 変数スコープ</h3>
<p>ここで、pythonでのスコープを確認する。</p>
<p>例7-4, 例7-5 は、<a href="https://github.com/fluentpython/example-code/blob/master/07-closure-deco/global_x_local.rst">example-code/global_x_local.rst at master · fluentpython/example-code</a>　が該当するようだ。</p>
<p>ローカル変数を、globalとして扱うための説明で、nonlocalの説明の前フリである。</p>
<h3 id="75-クロージャ">7.5 クロージャ</h3>
<p>クロージャは、理解されにくいのか。違うモノと混同されている。</p>
<ul>
<li>例 7-8
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/07-closure-deco/average_oo.py">example-code/average_oo.py at master · fluentpython/example-code</a></li>
</ul>
</li>
<li>例 7-9
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/07-closure-deco/average.py">example-code/average.py at master · fluentpython/example-code</a></li>
</ul>
</li>
</ul>
<p>図 7-1 ここの自由変数の図を読もう。</p>
<p>これ、例7-11 例7-12など</p>
<h3 id="76-nonlocal宣言">7.6 nonlocal宣言</h3>
<p>例 7-13 例 7-14 も既存か。</p>
<p>ここの説明が、python3になって、nonlocalが導入された説明になる。python2においてのやり方が書いている。p206</p>
<h3 id="77-シンプルなデコレータの実装">7.7 シンプルなデコレータの実装</h3>
<h4 id="771-コードの解説">7.7.1 コードの解説</h4>
<p>__name__ と __doc__ を覆い隠さないバージョン で、なんでこうなるかについても説明している。</p>
<p>functoolsのなかにある functools.wraps は、<a href="https://docs.python.org/ja/3/library/functools.html?highlight=functools%20wraps#functools.wraps">functools &mdash; 高階関数と呼び出し可能オブジェクトの操作 — Python 3.8.5 ドキュメント</a> であり、functools.update_wraps <a href="https://docs.python.org/ja/3/library/functools.html?highlight=functools%20wraps#functools.update_wrapper">functools &mdash; 高階関数と呼び出し可能オブジェクトの操作 — Python 3.8.5 ドキュメント</a> を呼んでいるので、こっちも見る必要がある。</p>
<h3 id="78-標準ライブラリのデコレータ">7.8 標準ライブラリのデコレータ</h3>
<p>property, classmethod, staticmethodの説明は後にするとのこと。functools.wraps は、既に紹介した。lru_cacheとsingledispatchの説明をするとのこと。</p>
<h4 id="781-functoolslru_cache-を用いたメモ化">7.8.1 functools.lru_cache を用いたメモ化</h4>
<dl>
<dt>メモ化</dt>
<dd>ここのnoteの主旨からは外れるかも知れないが、lru_cache を「メモ化」という表現は、pythonにおける定訳だと気がつくまで、かなり違和感があった。
lru_cacheの概念を「メモ化」という概念で日本語として互換だと消化するまでに時間がかかったからです。記録してすぐに参照するというコアなアイディアを共有すると良かったのだと今にしては思う。納得しがたかったのは、自分が、lru_cacheの動作の方から考えていたからなのだろう。</dd>
</dl>
<p>ここでのコア・アイディアは、一回実行した結果をlru方式で記録しておく。その時の条件として、入力が一定なら、必ず同じ出力をするのであれば再利用が可能だから。というもの。なので引数と出力をメモっておく。ただ気をつけないといけないのは、プログラム内部で、乱数や時刻などを参照していると同じ結果にならないので、何でもかんでもメモ化していいという話にはならない。</p>
<p>また、キャッシュをシステムで多重に持つと副作用があるので、どのレイヤで何のキャッシュを持っているのか。を設計時に決めておかないといけない気がする。そのためには、最初からパフォーマンス計測を計画して、プログラムに組み込んでおく用心深さがいるのかもしれない。</p>
<p>当てずっぽでなく、データを収集する。は、話がfluent pythonから脱線したが、デコレータで気軽につかえるlru_cacheは、プログラミングテクニックとして、覚えておくのは良い。ちょっとずつ違うことを繰り返し参照する場面では強力な手助けになるだろう。</p>
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/07-closure-deco/fibo_demo.py">example-code/fibo_demo.py at master · fluentpython/example-code</a></li>
<li><a href="https://github.com/fluentpython/example-code/blob/master/07-closure-deco/fibo_demo_lru.py">example-code/fibo_demo_lru.py at master · fluentpython/example-code</a></li>
</ul>
<h4 id="782-シングルディスパッチのジェネリック関数">7.8.2 シングルディスパッチのジェネリック関数</h4>
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/07-closure-deco/generic.py">example-code/generic.py at master · fluentpython/example-code</a></li>
</ul>
<p>パッと見には、JavaやC++のオーバーロードと同等に感じるかも知れないが、p215で書かれている内容を、いまは理解できていない。得失点まで含めて人に説明できるようにならないと理解したとは言えないだろうし。</p>
<p>ここでの、抽象基底クラス(ABC)推しも、体感してみるのと、その便利さは何が代償なのかを確認しないとよくわからない。コードの拡張性とのトレードオフは、実行速度だったりすることもある。でも、pythonで書いている時点で、ある程度割り切りはできているはずで、その基準内であれば拡張性を優先するのはありえる話です。</p>
<h3 id="79-多重デコレータ">7.9 多重デコレータ</h3>
<p>デコレータを複数回実行すると何が起きているのかを記述している。p214</p>
<p>pythonポケットリファレンスのp273 16-1-7 デコレータ構文を利用する</p>
<p>の記述では、よくわからない挙動の確認に。ここと次の部分は有用だと感じた。</p>
<p>「実践Python3」の 2.4.2 クラスデコレータ p59 に、多重デコレータの適用順がある。クラスが生成されてから、下から上に向かって順に適用されていく。との記述あり。クラスデコレータと、関数デコレータの評価順を一応確認しておくこと。2020/07/31</p>
<h3 id="710-パラメータ化デコレータ">7.10 パラメータ化デコレータ</h3>
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/07-closure-deco/registration.py">example-code/registration.py at master · fluentpython/example-code</a></li>
</ul>
<p>p216 の本節の最初の行を、なぜにpythonポケットリファレンスは、書いていないのか。経験を積むとわかるのだろうか。でも紙面が少ないから削られたのか。わからないけどもここは、自分で書き込みをして補っておく場面だよな。</p>
<p>いや、本に書き込むスペースぐらいでは足りないので、書き付けた紙を挟んでおくと、まだまだ書けるぞ。</p>
<h4 id="7101-登録デコレータのパラメータ化">7.10.1 登録デコレータのパラメータ化</h4>
<p>p217 ここで、デコレータファクトリの説明をしている。</p>
<h4 id="7102-clockデコレータのパラメータ化">7.10.2 clockデコレータのパラメータ化</h4>
<h3 id="711-本章のまとめ">7.11 本章のまとめ</h3>
<p>メタプログラミングの入り口かぁ。</p>
<h3 id="712-参考文献">7.12 参考文献</h3>
<p>Soapbox の「自由変数」に関する記述が気になった。</p>
<p>あと、pythonのデコレータと、デザインパターンのDecorator</p>
<h2 id="8章-オブジェクト参照可変性リサイクル">8章 オブジェクト参照、可変性、リサイクル</h2>
<p>8章のテーマは、オブジェクトと、オブジェクトにつけられた「名前」の区別をする。という話とのこと。</p>
<p>一時期よく見かけた、変数は箱のメタファーは間違っている。という話をpythonからの視点で説明する。</p>
<ul>
<li>オブジェクトの同一性(identity)</li>
<li>値(value)</li>
<li>エイリアス(alias)</li>
</ul>
<p>の概念を説明し、shallow copyとdeep copy を説明する。</p>
<h3 id="81-変数--箱">8.1 変数 != 箱</h3>
<p>確保されたメモリ領域へのラベルという解釈をした。</p>
<h3 id="82-同一性等価性エイリアス">8.2 同一性、等価性、エイリアス</h3>
<p>例 8-3 は、とくに簡単なのでサンプルプログラムはない模様。同じオブジェクトを別の名前が、指している例</p>
<p>aliasと、同じ値のオブジェクトを持っているだけでは、意味が違う。この意味は、誤解しているとバグう生みそう。</p>
<p>p233の、Python言語リファレンスの引用、 <a href="https://docs.python.org/ja/3/reference/datamodel.html#objects-values-and-types">3. データモデル — Python 3.8.5 ドキュメント</a>
は、fluent pythonの訳と、有志で日本語にしている訳では、表現は異なっていますが、大意は同じものだと思うので、左記にlinkをはっておきました。</p>
<p>内容が同じでも、オブジェクトのID<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup> は異なる。実装依存であっても、形式と意味する内容が決められているという部分が大事で、オブジェクトが存在している間は不変だということがキモっぽい。</p>
<h4 id="821--と-is-の使い分け">8.2.1 == と is の使い分け</h4>
<p>この部分、pythonポケットリファレンスだと、さすがに記述はあってもどういう風に使うのかを理解できるようになるのを期待したい。</p>
<p>典型例として、</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
</code></pre></div><p>があるので、Noneかどうかを高速に比較したい。という、検査目的を感じた。</p>
<p>ダンダーとして、 __eq__ の話に及んでいるので、2つのオブジェクトが、中身を検査するのが、コストが高いというのは理解できたと思う。shallow copyやdeep copyへのネタ振りでもあろう。</p>
<h4 id="822-タプルの相対的な不変性">8.2.2 タプルの相対的な不変性</h4>
<p>ここのタプルが不変だという話を理解しておかないと、参照先では変化しうるけど、タプルなんで、そんなことない。って思い込みそうなので、読んでおきましょう。</p>
<h3 id="83-デフォルトのコピーは浅い">8.3 デフォルトのコピーは「浅い」</h3>
<p>ここの実験も、見ているだけだと、そうやな。って思うだけ。で、期待しない動きになってから、ここを読み返すことになる。</p>
<h4 id="831-任意のオブジェクトの深いコピーと浅いコピー">8.3.1 任意のオブジェクトの「深い」コピーと「浅い」コピー</h4>
<p>deep copy と shallow copyの話。</p>
<p>例 8-8 生徒を乗せたり降ろしたりするバス</p>
<p>のコード例は、</p>
<p><a href="https://github.com/fluentpython/example-code/blob/master/08-obj-ref/bus.py">example-code/bus.py at master · fluentpython/example-code</a></p>
<p>上記のコードを使って</p>
<ul>
<li>copy</li>
<li>deepcopy</li>
</ul>
<p>の実例</p>
<h3 id="84-参照としての関数の引数">8.4 参照としての関数の引数</h3>
<p>pythonは、共有渡し(call by sharing)だけということだが、c言語をやってきた自分には、call by valueとcall by referenceという言い方が馴染んでいる。</p>
<h4 id="841-引数のデフォルト値に可変型を使うのは考えもの">8.4.1 引数のデフォルト値に可変型を使うのは考えもの</h4>
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/08-obj-ref/haunted_bus.py">example-code/haunted_bus.py at master · fluentpython/example-code</a></li>
</ul>
<p>問題があることを、例 8-12 可変なデフォルト値の危険性を説明する簡単なクラス で説明している。生徒の幽霊がでるお化けバス haunted bugってことみたい。</p>
<p><a href="http://pythontutor.com/live.html#code=%22%22%22%0A%3E%3E%3E%20bus1%20%3D%20HauntedBus%28%5B'Alice',%20'Bill'%5D%29%0A%3E%3E%3E%20bus1.passengers%0A%5B'Alice',%20'Bill'%5D%0A%3E%3E%3E%20bus1.pick%28'Charlie'%29%0A%3E%3E%3E%20bus1.drop%28'Alice'%29%0A%3E%3E%3E%20bus1.passengers%0A%5B'Bill',%20'Charlie'%5D%0A%3E%3E%3E%20bus2%20%3D%20HauntedBus%28%29%0A%3E%3E%3E%20bus2.pick%28'Carrie'%29%0A%3E%3E%3E%20bus2.passengers%0A%5B'Carrie'%5D%0A%3E%3E%3E%20bus3%20%3D%20HauntedBus%28%29%0A%3E%3E%3E%20bus3.passengers%0A%5B'Carrie'%5D%0A%3E%3E%3E%20bus3.pick%28'Dave'%29%0A%3E%3E%3E%20bus2.passengers%0A%5B'Carrie',%20'Dave'%5D%0A%3E%3E%3E%20bus2.passengers%20is%20bus3.passengers%0ATrue%0A%3E%3E%3E%20bus1.passengers%0A%5B'Bill',%20'Charlie'%5D%0A%0A%0A%3E%3E%3E%20dir%28HauntedBus.__init__%29%20%20%23%20doctest%3A%20%2BELLIPSIS%0A%5B'__annotations__',%20'__call__',%20...,%20'__defaults__',%20...%5D%0A%3E%3E%3E%20HauntedBus.__init__.__defaults__%0A%28%5B'Carrie',%20'Dave'%5D,%29%0A%3E%3E%3E%20HauntedBus.__init__.__defaults__%5B0%5D%20is%20bus2.passengers%0ATrue%0A%0A%22%22%22%0A%0A%23%20BEGIN%20HAUNTED_BUS_CLASS%0Aclass%20HauntedBus%3A%0A%20%20%20%20%22%22%22A%20bus%20model%20haunted%20by%20ghost%20passengers%22%22%22%0A%0A%20%20%20%20def%20__init__%28self,%20passengers%3D%5B%5D%29%3A%20%20%23%20%3C1%3E%0A%20%20%20%20%20%20%20%20self.passengers%20%3D%20passengers%20%20%23%20%3C2%3E%0A%0A%20%20%20%20def%20pick%28self,%20name%29%3A%0A%20%20%20%20%20%20%20%20self.passengers.append%28name%29%20%20%23%20%3C3%3E%0A%0A%20%20%20%20def%20drop%28self,%20name%29%3A%0A%20%20%20%20%20%20%20%20self.passengers.remove%28name%29%0A%23%20END%20HAUNTED_BUS_CLASS%0Abus1%20%3D%20HauntedBus%28%5B'Alice',%20'Bill'%5D%29%0Abus1.pick%28'Charlie'%29%0Abus1.drop%28'Alice'%29%0Abus2%20%3D%20HauntedBus%28%29%0Abus2.pick%28'Carrie'%29%0Abus3%20%3D%20HauntedBus%28%29%0Abus3.pick%28'Alice'%29%0Abus2.pick%28'Bill'%29%0Abus2.drop%28'Carrie'%29%0Abus3.pick%28'Carrie'%29%0A&amp;cumulative=false&amp;curInstr=42&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-live.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">http://pythontutor.com/live.html#code=%22%22%22%0A%3E%3E%3E%20bus1%20%3D%20HauntedBus%28%5B'Alice',%20'Bill'%5D%29%0A%3E%3E%3E%20bus1.passengers%0A%5B'Alice',%20'Bill'%5D%0A%3E%3E%3E%20bus1.pick%28'Charlie'%29%0A%3E%3E%3E%20bus1.drop%28'Alice'%29%0A%3E%3E%3E%20bus1.passengers%0A%5B'Bill',%20'Charlie'%5D%0A%3E%3E%3E%20bus2%20%3D%20HauntedBus%28%29%0A%3E%3E%3E%20bus2.pick%28'Carrie'%29%0A%3E%3E%3E%20bus2.passengers%0A%5B'Carrie'%5D%0A%3E%3E%3E%20bus3%20%3D%20HauntedBus%28%29%0A%3E%3E%3E%20bus3.passengers%0A%5B'Carrie'%5D%0A%3E%3E%3E%20bus3.pick%28'Dave'%29%0A%3E%3E%3E%20bus2.passengers%0A%5B'Carrie',%20'Dave'%5D%0A%3E%3E%3E%20bus2.passengers%20is%20bus3.passengers%0ATrue%0A%3E%3E%3E%20bus1.passengers%0A%5B'Bill',%20'Charlie'%5D%0A%0A%0A%3E%3E%3E%20dir%28HauntedBus.__init__%29%20%20%23%20doctest%3A%20%2BELLIPSIS%0A%5B'__annotations__',%20'__call__',%20...,%20'__defaults__',%20...%5D%0A%3E%3E%3E%20HauntedBus.__init__.__defaults__%0A%28%5B'Carrie',%20'Dave'%5D,%29%0A%3E%3E%3E%20HauntedBus.__init__.__defaults__%5B0%5D%20is%20bus2.passengers%0ATrue%0A%0A%22%22%22%0A%0A%23%20BEGIN%20HAUNTED_BUS_CLASS%0Aclass%20HauntedBus%3A%0A%20%20%20%20%22%22%22A%20bus%20model%20haunted%20by%20ghost%20passengers%22%22%22%0A%0A%20%20%20%20def%20__init__%28self,%20passengers%3D%5B%5D%29%3A%20%20%23%20%3C1%3E%0A%20%20%20%20%20%20%20%20self.passengers%20%3D%20passengers%20%20%23%20%3C2%3E%0A%0A%20%20%20%20def%20pick%28self,%20name%29%3A%0A%20%20%20%20%20%20%20%20self.passengers.append%28name%29%20%20%23%20%3C3%3E%0A%0A%20%20%20%20def%20drop%28self,%20name%29%3A%0A%20%20%20%20%20%20%20%20self.passengers.remove%28name%29%0A%23%20END%20HAUNTED_BUS_CLASS%0Abus1%20%3D%20HauntedBus%28%5B'Alice',%20'Bill'%5D%29%0Abus1.pick%28'Charlie'%29%0Abus1.drop%28'Alice'%29%0Abus2%20%3D%20HauntedBus%28%29%0Abus2.pick%28'Carrie'%29%0Abus3%20%3D%20HauntedBus%28%29%0Abus3.pick%28'Alice'%29%0Abus2.pick%28'Bill'%29%0Abus2.drop%28'Carrie'%29%0Abus3.pick%28'Carrie'%29%0A&amp;cumulative=false&amp;curInstr=42&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-live.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</a></p>
<p>で、実行してみて解ったことがある。</p>
<h4 id="842-可変な引数を使うプログラムを頑強に">8.4.2 可変な引数を使うプログラムを頑強に</h4>
<p>例 8-15 引数変更の危険性を示す簡単なクラスとして下記の例がでている。</p>
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/08-obj-ref/twilight_bus.py">example-code/twilight_bus.py at master · fluentpython/example-code</a></li>
</ul>
<p>passengerのチェックをすることで、独立というか、別物にできる。ここは、また訪れて確認しないとわかった気にならないな。</p>
<p><a href="http://pythontutor.com/live.html#code=%22%22%22%0A%3E%3E%3E%20basketball_team%20%3D%20%5B'Sue',%20'Tina',%20'Maya',%20'Diana',%20'Pat'%5D%0A%3E%3E%3E%20bus%20%3D%20TwilightBus%28basketball_team%29%0A%3E%3E%3E%20bus.drop%28'Tina'%29%0A%3E%3E%3E%20bus.drop%28'Pat'%29%0A%3E%3E%3E%20basketball_team%0A%5B'Sue',%20'Maya',%20'Diana'%5D%0A%22%22%22%0A%0A%23%20BEGIN%20TWILIGHT_BUS_CLASS%0Aclass%20TwilightBus%3A%0A%20%20%20%20%22%22%22A%20bus%20model%20that%20makes%20passengers%20vanish%22%22%22%0A%0A%20%20%20%20def%20__init__%28self,%20passengers%3DNone%29%3A%0A%20%20%20%20%20%20%20%20if%20passengers%20is%20None%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20self.passengers%20%3D%20%5B%5D%20%20%23%20%3C1%3E%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20self.passengers%20%3D%20passengers%20%20%23%3C2%3E%0A%0A%20%20%20%20def%20pick%28self,%20name%29%3A%0A%20%20%20%20%20%20%20%20self.passengers.append%28name%29%0A%0A%20%20%20%20def%20drop%28self,%20name%29%3A%0A%20%20%20%20%20%20%20%20self.passengers.remove%28name%29%20%20%23%20%3C3%3E%0A%23%20END%20TWILIGHT_BUS_CLASS%0Abasketball_team%20%3D%20%5B'Sue',%20'Tina',%20'Maya',%20'Diana',%20'Pat'%5D%0Abus%20%3D%20TwilightBus%28basketball_team%29%0Abus1%20%3D%20TwilightBus%28basketball_team%29%0Abus2%20%3D%20TwilightBus%28basketball_team%29%0Abus1.drop%28%22Tina%22%29%0Abus2.drop%28%22Pat%22%29&amp;cumulative=false&amp;curInstr=26&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-live.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">http://pythontutor.com/live.html#code=%22%22%22%0A%3E%3E%3E%20basketball_team%20%3D%20%5B'Sue',%20'Tina',%20'Maya',%20'Diana',%20'Pat'%5D%0A%3E%3E%3E%20bus%20%3D%20TwilightBus%28basketball_team%29%0A%3E%3E%3E%20bus.drop%28'Tina'%29%0A%3E%3E%3E%20bus.drop%28'Pat'%29%0A%3E%3E%3E%20basketball_team%0A%5B'Sue',%20'Maya',%20'Diana'%5D%0A%22%22%22%0A%0A%23%20BEGIN%20TWILIGHT_BUS_CLASS%0Aclass%20TwilightBus%3A%0A%20%20%20%20%22%22%22A%20bus%20model%20that%20makes%20passengers%20vanish%22%22%22%0A%0A%20%20%20%20def%20__init__%28self,%20passengers%3DNone%29%3A%0A%20%20%20%20%20%20%20%20if%20passengers%20is%20None%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20self.passengers%20%3D%20%5B%5D%20%20%23%20%3C1%3E%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20self.passengers%20%3D%20passengers%20%20%23%3C2%3E%0A%0A%20%20%20%20def%20pick%28self,%20name%29%3A%0A%20%20%20%20%20%20%20%20self.passengers.append%28name%29%0A%0A%20%20%20%20def%20drop%28self,%20name%29%3A%0A%20%20%20%20%20%20%20%20self.passengers.remove%28name%29%20%20%23%20%3C3%3E%0A%23%20END%20TWILIGHT_BUS_CLASS%0Abasketball_team%20%3D%20%5B'Sue',%20'Tina',%20'Maya',%20'Diana',%20'Pat'%5D%0Abus%20%3D%20TwilightBus%28basketball_team%29%0Abus1%20%3D%20TwilightBus%28basketball_team%29%0Abus2%20%3D%20TwilightBus%28basketball_team%29%0Abus1.drop%28%22Tina%22%29%0Abus2.drop%28%22Pat%22%29&amp;cumulative=false&amp;curInstr=26&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-live.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</a></p>
<p>確保したオブジェクトを使いまわすのは、C言語の、call by referenceと同じように思ってしまうが、本章のSoapboxの部分もあるので、また読み直して理解に努めたい。</p>
<p>なお、前節 「8.4.1 可変な引数を使うプログラムを頑強に」と異なるのは、可変な引数の内容が、[]な時と、そうでない時に、同じオブジェクトを指していないことが確認できる。前者と、初期値を[]かどうかで振り分けている本節のプログラムの差については、理解した気がするが。 see also 本章のSoapbox</p>
<h3 id="85-delとガベージコレクション">8.5 delとガベージコレクション</h3>
<p>delは、名前を削除し、ガベージコレクションは、オブジェクトを削除する。CPythonのガベージコレクションは、reference counterを使っているとのこと。ガベージコレクションはそれだけで、一つの学ぶべき分野であるが、fluent python p245 ではreference cunterの説明がなされている。</p>
<p>weakref.finalize ってので、オブジェクトが削除されたときに実行されるコールバックを設定できることを知る。</p>
<p>名前を削除すると、到達性がなくなり、ガベージコレクションを動くという連鎖が理解できたらいいのかな。</p>
<p>CPython 2.0 は、世代別ガベージコレクターとあるが、脚注に、監訳者からの説明あり。 p245</p>
<h3 id="86-弱参照">8.6 弱参照</h3>
<p>オブジェクトで、置いておく必要がないもの。本書では、cacheが例に上がってきている。を積極的にメモリーへ返却したい時にどうするか。という話と、こんなん事前に調べとかないとわかる訳ないやん。的なtipsもあって、p247 の部分はまた再訪します。</p>
<h4 id="861-コントweak-value-dictionary">8.6.1 コント「Weak Value Dictionary」</h4>
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/08-obj-ref/cheese.py">example-code/cheese.py at master · fluentpython/example-code</a></li>
</ul>
<p>解説を読んでも、疑問だったので、globalの定義を読み直さないと間違えそう。他の言語のフワッとした感覚だといかんな。pythonポケットリファレンス p183にて確認する。</p>
<p>私の理解によるスコープは、2つの条件で決定される。</p>
<ol>
<li>使用する場所(宣言する、確保すると考えてもいい) #A</li>
<li>代入する場所 #B</li>
</ol>
<p>#Aが関数外で宣言というか確保されていると、グローバル変数となり、関数宣言をしてから、グローバルと同じ関数名を使って代入をすると、別途ローカル変数として扱われる。グローバル変数にアクセスしたいなら、global宣言が必要。というか別の名前にするという手で問題にならないのか。古き変数名に属性を持たせるという方式だったら困らないってことか。</p>
<p>また、グローバル変数は行儀がよくないから、クラスの中に閉じ込めるクラス変数などに閉じ込めるので、ここを意識してこなっかった。</p>
<p>クロージャの場合は、関数宣言をして、そのまた中から、外の関数で定義された自由変数にアクセスする。ただ変数を見たいというだけなら、再代入を伴わないことはマレなので、やっばりnonlocal宣言は必要か。</p>
<p>#B の再代入というのがキモな気がする。その時にどの変数にアクセスしたいのかを明確に意識しそう。</p>
<p>あと、WeakSetの説明は、リファレンスで書いていない、注意すべきことを書いているので読んでおけ。p250</p>
<h4 id="862-弱参照の制約">8.6.2 弱参照の制約</h4>
<p>dictやListについての制約があること、そしてその制約を外す方法 p250</p>
<h3 id="87-pythonが不変型で使っている魔術">8.7 Pythonが不変型で使っている魔術</h3>
<p>この節は、飛ばしていいとのことで、何周かして余裕があったら読む。</p>
<h3 id="88-本章のまとめ">8.8 本章のまとめ</h3>
<p>ここの部分を読んで、内容の確認をする。</p>
<h3 id="89-参考文献">8.9 参考文献</h3>
<h3 id="soapbox">Soapbox</h3>
<p>また、Soapboxの「共有渡しによる引数の受け渡し」を読んで、単純に、call by reference という言い方ではいかんというのがやはり理解できていない。p256</p>
<blockquote>
<p>Pythonの関数は引数のコピーを取得しますが、引数は常に参照です。
そのため、参照されているオブジェクトの値は可変であれば変更されることもありますが、そのIDは変更できません。
また、関数は引数で指定されている参照のコピーを取得するので、再バインドしても関数の外側には影響を与えません。</p>
</blockquote>
<p>については、</p>
<blockquote>
<p>Pythonの関数は引数のコピーを取得しますが、引数は常に参照です。</p>
</blockquote>
<p>多分理解できたとオ思う。</p>
<blockquote>
<p>そのため、参照されているオブジェクトの値は可変であれば変更されることもありますが、そのIDは変更できません。</p>
</blockquote>
<p>前段は、そうだと思うが、内容が変わったら、IDが変化するんじゃないのか。IDが変更できないということは、内容を最終的に変わらないということを意味しているのか。</p>
<blockquote>
<p>また、関数は引数で指定されている参照のコピーを取得するので、再バインドしても関数の外側には影響を与えません。</p>
</blockquote>
<p>参照のコピーといっても、shallow copyなので、同じオブジェクトを参照しているのではないのか。そして「再バインド」という言葉が出てくるが、何となくの意味でなく、pythonにおける変数の再バインドとは、何か。再代入のことなのか?</p>
<p>という疑問があるので、やっばり理解しているとは思えない。また、わかったら追記する。</p>
<dl>
<dt>2020/08/01</dt>
<dd>idは変わらない。というのは、下記のようだ。</dd>
</dl>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;aaa&#34;</span><span class="p">,</span><span class="s2">&#34;bbb&#34;</span><span class="p">,</span><span class="s2">&#34;ccc&#34;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">fna</span><span class="p">(</span><span class="n">arga</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">b</span> <span class="o">=</span> <span class="n">arga</span>
<span class="o">...</span>     <span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&#34;ddd&#34;</span><span class="p">)</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="o">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">fnb</span><span class="p">(</span><span class="n">argb</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">c</span> <span class="o">=</span> <span class="n">argb</span>
<span class="o">...</span>     <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&#34;eee&#34;</span><span class="p">)</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="o">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;aaa&#39;</span><span class="p">,</span> <span class="s1">&#39;bbb&#39;</span><span class="p">,</span> <span class="s1">&#39;ccc&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fna</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;aaa&#39;</span><span class="p">,</span> <span class="s1">&#39;bbb&#39;</span><span class="p">,</span> <span class="s1">&#39;ccc&#39;</span><span class="p">,</span> <span class="s1">&#39;ddd&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fnb</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;aaa&#39;</span><span class="p">,</span> <span class="s1">&#39;bbb&#39;</span><span class="p">,</span> <span class="s1">&#39;ccc&#39;</span><span class="p">,</span> <span class="s1">&#39;ddd&#39;</span><span class="p">,</span> <span class="s1">&#39;eee&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;aaa&#39;</span><span class="p">,</span> <span class="s1">&#39;bbb&#39;</span><span class="p">,</span> <span class="s1">&#39;ccc&#39;</span><span class="p">,</span> <span class="s1">&#39;ddd&#39;</span><span class="p">,</span> <span class="s1">&#39;eee&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mi">140204036553472</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fna</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;aaa&#39;</span><span class="p">,</span> <span class="s1">&#39;bbb&#39;</span><span class="p">,</span> <span class="s1">&#39;ccc&#39;</span><span class="p">,</span> <span class="s1">&#39;ddd&#39;</span><span class="p">,</span> <span class="s1">&#39;eee&#39;</span><span class="p">,</span> <span class="s1">&#39;ddd&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mi">140204036553472</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fnb</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;aaa&#39;</span><span class="p">,</span> <span class="s1">&#39;bbb&#39;</span><span class="p">,</span> <span class="s1">&#39;ccc&#39;</span><span class="p">,</span> <span class="s1">&#39;ddd&#39;</span><span class="p">,</span> <span class="s1">&#39;eee&#39;</span><span class="p">,</span> <span class="s1">&#39;ddd&#39;</span><span class="p">,</span> <span class="s1">&#39;eee&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mi">140204036553472</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;aaa&#39;</span><span class="p">,</span> <span class="s1">&#39;bbb&#39;</span><span class="p">,</span> <span class="s1">&#39;ccc&#39;</span><span class="p">,</span> <span class="s1">&#39;ddd&#39;</span><span class="p">,</span> <span class="s1">&#39;eee&#39;</span><span class="p">,</span> <span class="s1">&#39;ddd&#39;</span><span class="p">,</span> <span class="s1">&#39;eee&#39;</span><span class="p">]</span>
</code></pre></div><p>オブジェクトのIDは不変でも、内容は変わっていくってことは、こういうことか。</p>
<h2 id="9章-pythonic-なオブジェクト">9章 Pythonic なオブジェクト</h2>
<p>ここでは、ユーザ定義型を作るテクニックについて学ぶようだ。p259</p>
<p>この章で学ぶのは、</p>
<ul>
<li>repr()やbytes()など、オブジェクトを異なる表現で示す各種の組み込み関数を使えるようにする方法</li>
<li>別バージョンのコンストラクタをクラスメソッドとして実装する方法</li>
<li>組み込みメソッドのformat()や、str.format()メソッドが用いる書式指定ミニ言語の拡張方法</li>
<li>読み取り専用属性へのアクセス</li>
<li>セットやdictのキーとして、利用するためのハッシュ可能オブジェクト</li>
<li>__slots__ によるメモリの節約</li>
</ul>
<p>と、下記の議論をするようだ。</p>
<ul>
<li>@classmethodおよび@staticmethodデコレータをいつ、どのように使用すべきか。</li>
<li>Pythonのプライベート属性とプロテクト属性の用法、慣例そして制約</li>
</ul>
<p>どういう関連でこれを本章に入れているのかは、最初の段階ではよくわからない。読み進めるとおいおいとわかるのだろう。</p>
<h3 id="91-オブジェクトの表現">9.1 オブジェクトの表現</h3>
<ul>
<li>repr() &mdash; __repr__</li>
<li>str() &mdash; __str__</li>
</ul>
<p>の説明をしたあとに、</p>
<ul>
<li>__bytes__</li>
<li>__format__</li>
</ul>
<p>をする模様だ。</p>
<p>ってことで、この章もダンダーメソッドについての説明であるようだ。</p>
<h3 id="92-vectorクラス再訪">9.2 Vectorクラス再訪</h3>
<p>例 9-2</p>
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/09-pythonic-obj/vector2d_v0.py">example-code/vector2d_v0.py at master · fluentpython/example-code</a></li>
</ul>
<p>typecodeについては、fluent python p52 または、<a href="https://docs.python.org/ja/3/library/array.html?highlight=%E3%82%BF%E3%82%A4%E3%83%97%E3%82%B3%E3%83%BC%E3%83%89">array &mdash; 効率のよい数値アレイ — Python 3.8.5 ドキュメント</a> にある「型コード」を参照せよ。fluent pythonと、公式ドキュメントの用語が違うのは、訳者が違ったり、翻訳の用語リスト、翻訳メモリが違うのだろう。読者側で、変換して吸収するしかない。</p>
<h3 id="93-別バージョンのコンストラクタ">9.3 別バージョンのコンストラクタ</h3>
<p>classmethodについては、まずは気にせずに読み進めて戻るのがいいってこと。?</p>
<ul>
<li><a href="https://docs.python.org/ja/3/reference/datamodel.html#types">3. データモデル — Python 3.8.5 ドキュメント</a> のクラスメソッドで検索</li>
<li><a href="https://docs.python.org/ja/3/library/functions.html?highlight=classmethod#classmethod">組み込み関数 — Python 3.8.5 ドキュメント</a>
<ul>
<li>classmethodについては、ここの説明だけで理解するのは難しい。</li>
</ul>
</li>
</ul>
<p>とか、見ても、もっと端的に説明してもらってから詳細に入ってくれないか。とか思う。</p>
<p>クラスに属している、メソッドをインスタンス経由でなく、「クラス名.メソッド名」という形でアクセスして実行する形になるのかとか思うが、</p>
<p>Effective python 「項目 24:@classmethodポリモルフィズムを使って、オブジェクトをジェネリックに構築する」p64-p68 とりわけ、p67 での、
インスタンスメソッドポリモルフィズムと、@classmthodポリモルフィズムの対比の記述が参考になるか。</p>
<p>classmethodデコレータの説明は、次節で説明してもらえるようだ。</p>
<h3 id="94-classmethodとstaticmethod">9.4 classmethodとstaticmethod</h3>
<p>p264</p>
<blockquote>
<p>インスタンスでなく、クラスに対する操作を行うメソッドを定義するときに用います。</p>
</blockquote>
<p>のこの周辺を読むのと、変数名の慣習について言及がある。あと、クラスに対するは、クラスに属する操作とも読めるか。クラスをインスタンス化しなくもいいというのは、そういう意味にも取れるか。</p>
<p>staticmethodは、classmethodとの対比で出てくる。対称性として、存在しているとなると、どう使うのか。ここに書いてある方法だけなのか。例外はあるかとか思うが、そんなことは、後からでいいか。</p>
<h3 id="95-出力フォーマット">9.5 出力フォーマット</h3>
<p>p265 実際にデリゲートされるメソッドについて書いてある。デリゲートってか実際に動作する部分と書いておくのがいいか。</p>
<ul>
<li>
<p>書式指定ミニ言語仕様 <a href="https://docs.python.org/ja/3/library/string.html#format-specification-mini-language">string &mdash; 一般的な文字列操作 — Python 3.8.5 ドキュメント</a></p>
</li>
<li>
<p>str-format構文の例 <a href="https://docs.python.org/ja/3/library/string.html#format-examples">string &mdash; 一般的な文字列操作 — Python 3.8.5 ドキュメント</a></p>
<ul>
<li>{:}の例もここ。</li>
</ul>
</li>
</ul>
<p>自分の作ったクラスで、書式指定ミニ言語仕様に沿った、出力をさせたいときにどうするか。を示している。</p>
<h3 id="96-ハッシュ可能なvector2d">9.6 ハッシュ可能なVector2d</h3>
<p>自分の作ったクラスを、Setなどに入れて使いたいなら、ハッシュ可能にする必要がある。そして、p269-274は、その方法についてプログラムを交えて説明している。</p>
<ul>
<li>例9-9
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/09-pythonic-obj/vector2d_v3.py">example-code/vector2d_v3.py at master · fluentpython/example-code</a></li>
</ul>
</li>
</ul>
<p>上記で、実装されているダンダーたち、読み取り専用プロパティにする。@propertyデコレータの詳細は19章になるとのこと。19章に至ったら戻ってくるか。</p>
<p>そして、 __hash__ として、どういう値が良いのかの例を出している。必ずしも必須ではないが、事実上readonlyなプロバティにする必要があったのもここで説明される。p271</p>
<h3 id="97-プライベート属性とプロテクト属性">9.7 プライベート属性と「プロテクト」属性</h3>
<p>プライベート属性がどうやって実装されているのかを明らかにして、Pythonプログラマは自分で自分の足を撃ち抜ける自由もある。ので、正気なプログラマに便利な方法を提供している。</p>
<h3 id="98-クラス属性-__slots__-によるメモリ節約">9.8 クラス属性 __slots__ によるメモリ節約</h3>
<ul>
<li>例9-11
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/09-pythonic-obj/vector2d_v3_slots.py">example-code/vector2d_v3_slots.py at master · fluentpython/example-code</a></li>
</ul>
</li>
</ul>
<p>ここの記述を使うハメになるのなら、NumPyやPandasを検討しようというのは良い。</p>
<h4 id="981-__slots__-の問題点">9.8.1 __slots__ の問題点</h4>
<p>p280 使うなら読んどけ。</p>
<h3 id="99-クラス属性の上書き">9.9 クラス属性の上書き</h3>
<p>クラス名で動作を変えたい時に役立つ。</p>
<h3 id="910-本章のまとめ">9.10 本章のまとめ</h3>
<h3 id="911-参考文献">9.11 参考文献</h3>
<h3 id="soapbox-1">Soapbox</h3>
<h2 id="10章-シーケンスをばらしてハッシュしてスライスする">10章 シーケンスをばらして、ハッシュして、スライスする</h2>
<p>ダックタイピングについてより考察を深める。一章で出てきた、 __len__、 __getitem__ をより詳細などなど。「非形式なインターフェースとしてのプロトコル」という話題が出てくるようだが、概念と具象をつなげる部分に興味がある。</p>
<p>コラムの「多次元ベクトルアプリケーション」は良い。意欲が出たが、一気に全部はできないので、まずは本書を一通りやってから。</p>
<h3 id="101-ユーザ定義のシーケンス型vector">10.1 ユーザ定義のシーケンス型(Vector)</h3>
<p>継承でなく、compositionで実装するのはなぜか。</p>
<h3 id="102-vector2d互換vectorテイク1">10.2 Vector2d互換(Vectorテイク1)</h3>
<p>例10-1で、コンストラクタがこっちがベストプラクティスってことで。</p>
<p>質問がでていた、reprとstrの違いについては、p291のサソリのマーク部分で、その答えがある。</p>
<ul>
<li>例10-2
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/10-seq-hacking/vector_v1.py">example-code/vector_v1.py at master · fluentpython/example-code</a></li>
<li>上記のプログラムの説明は、p291からp292 にかけて、説明がある。</li>
<li>repr()の実装、__repr__をプログラミングするにあたっての注意点は、p293にある。</li>
</ul>
</li>
</ul>
<h3 id="103-プロトコルとダックタイピング">10.3 プロトコルとダックタイピング</h3>
<p>ずっと気になっていた、プロトコルの説明が、本節である。fluentpythonで述べられている、プロトコルの定義って、他でも使われているのか?</p>
<blockquote>
<p>オブジェクト指向プログラミングにおけるプロトコルは非形式的なインターフェースで、コードではなくドキュメントでのみ定義されるものです。</p>
</blockquote>
<p>という、文章は次の行から具体例を示しているが、この様な形式でコードを実装せよ。という例が書いてあり、「非形式的なインターフェース」って何だ?と、「コードでなくドキュメント」ってのは何を指しているのか、私に取っては自明でないが、読み進めていくと理解できるといいな。</p>
<p>他のOOPをする言語だと、確かにシーケンス型を継承しないと、そのような動作にならない。という前提で、そのようなプログラミング言語に対して、pythonはダックタイピングで、ダンダーメソッドを整備すれば、同じモノとして見なす。という意味なんだろう。と理解しておく。</p>
<p>そして、fluentpythonにおいてダックタイピングの定義っぽいものは、p294にある。</p>
<h3 id="104-スライス可能てシーケンスvectorテイク2">10.4 スライス可能てシーケンス(Vectorテイク2)</h3>
<p>シーケンスプロトコルの処理を作るのに、これから記述していく。</p>
<h4 id="1041-スライスの仕組み">10.4.1 スライスの仕組み</h4>
<ul>
<li><a href="https://docs.python.org/ja/3/reference/datamodel.html?highlight=slice%20indices#slice.indices">3. データモデル — Python 3.8.5 ドキュメント</a>
<ul>
<li>slice.indices についてのドキュメント</li>
<li>スライス(slice)オブジェクト　の説明</li>
<li>class slice に関して
<ul>
<li><a href="https://docs.python.org/ja/3/library/functions.html#slice">組み込み関数 — Python 3.8.5 ドキュメント</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1042-スライス対応版の__getitem__">10.4.2 スライス対応版の__getitem__</h4>
<ul>
<li>
<p>例10-6 (vector_v2.py)</p>
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/10-seq-hacking/vector_v2.py">example-code/vector_v2.py at master · fluentpython/example-code</a></li>
</ul>
</li>
<li>
<p>isinstanceで、何のオブジェクトかを判定して、どうしたらいいか。例示する。p298</p>
</li>
<li>
<p>何の例外を上げるか。どういうときに?</p>
</li>
</ul>
<h3 id="105-動的な属性アクセスvectorテイク3">10.5 動的な属性アクセス(Vectorテイク3)</h3>
<p>__getattr__ の紹介と使い方。</p>
<ul>
<li><a href="https://docs.python.org/ja/3/library/functions.html?highlight=getattr#getattr">getattr 組み込み関数 — Python 3.8.5 ドキュメント</a></li>
</ul>
<p>p299 ここで、求める属性がどういう風に検索されているか。を書いてくれている。</p>
<ol>
<li>インスタンスに名前があるか</li>
<li>クラスの中を検索</li>
<li>__getattr__</li>
</ol>
<p>で探すとあり、もうちょっと詳細に書いてある。</p>
<ul>
<li>例10-6
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/10-seq-hacking/vector_v3.py">example-code/vector_v3.py at master · fluentpython/example-code</a>
<ul>
<li>p300から302にかけて説明あり。</li>
<li>superがサラッとでてきているが、詳細は12.2節でやるとのこと。</li>
<li>__slots__ を使う誘惑に負けるな。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="106-ハッシュとより高速なvectorテイク4">10.6 ハッシュとより高速な==(Vectorテイク4)</h3>
<p>__hash__ と __eq__ の実装。そして、functools.reduceを使う。 lambda を使って、5!(5の階乗)を計算する方法については、p303にあり、reduceの基本的な方法を学ぶことができるが、次ページのp304にて、xorを取る3つの方法が例示されている。特に、(3)は、作者のお気に入りであるが、これは標準で付いてくるライブラリを知らないと、ついつい知っている(1)の方法に頼りがちなので、ここもfluent pythonを読んでて良かったなと。</p>
<p>__eq__ と、 __hash__ は、近接さておくというのは、たしかに。(理由は、p305を参照せよ)</p>
<p>p305は、map - reduce 演算の説明、この概念を知らない人には、必要な説明だろう。また、p306-307にかけて、zipについて紹介している。map - reduce系の処理をするなら、とても使い勝手ので、自分の道具箱に入れておけというのは、よくわかる。python ポケットリファレンスだとp94です。</p>
<p>allの使い方も例示があり、この手の書き方に慣れていないなら、参考になる部分だと思う。</p>
<ul>
<li><a href="https://docs.python.org/ja/3/library/functions.html?highlight=enumerate#enumerate">enumerate 組み込み関数 — Python 3.8.5 ドキュメント</a></li>
<li><a href="https://docs.python.org/ja/3/library/functions.html?highlight=zip#zip">zip</a></li>
</ul>
<h3 id="107-フォーマットvectorテイク5">10.7 フォーマット(Vectorテイク5)</h3>
<p>出力フォーマットを極座標系から、球面座標系へ変換するにあたって、コードを書き換える。既存の書式を書き換えないで拡張する方法について。</p>
<ul>
<li>例10-16 p309
<ul>
<li><a href="https://github.com/fluentpython/example-code/blob/master/10-seq-hacking/vector_v5.py">example-code/vector_v5.py at master · fluentpython/example-code</a></li>
<li>p309から、p315までコードの掲示と説明</li>
</ul>
</li>
</ul>
<h3 id="108-本章のまとめ">10.8 本章のまとめ</h3>
<p>やった内容の振り返り</p>
<h3 id="109-参考文献">10.9 参考文献</h3>
<p>ここで、最初に読んで良かったとおもうのは、p317の下記です。</p>
<blockquote>
<p>とても使い勝手のよい reduceは、高階関数で、これをfold, accumulate, aggregate, compress, inject という名でも呼ばれています。詳細は、英語版Wikipediaの「Fold(high-order fucntion)」を参照してください。</p>
</blockquote>
<p>でした。同じような概念を別の名前で呼んでいるなと、薄々は気がついていましたが、覚える概念が減ってありがたい。</p>
<h3 id="soapbox-2">Soapbox</h3>
<p>ここの章のSoapboxは、私に取って収穫が多い。</p>
<h4 id="非形式的なインターフェースとしてのプロトコル">非形式的なインターフェースとしてのプロトコル</h4>
<p>ここに来て、ようやく「非形式的なインターフェースとしてのプロトコル」という内容を補完する記述がでてくる。まずは読み進めてみないとわからない評価はできないな。P317</p>
<p>プロトコルとインターフェースは、11章の主題とのことです。11章の冒頭でも書かれるでしょうけど。</p>
<h4 id="ダックタイピングの起源">ダックタイピングの起源</h4>
<p>確かに本筋でないが、書いておきたいのはわかる。</p>
<h4 id="ユーザビリティを向上した安全な-__format__">ユーザビリティを向上した安全な __format__</h4>
<p>ユーザの要求と、困りそうなことを考えてのコードを書くには。</p>
<h4 id="pythonicなsumの探求">PythonicなSumの探求</h4>
<p>著者による、Pythonicとは何かについての意見の開陳と、pyhthonにいる自分の流儀が良いという流派の話と、pyhonicなコードとはいう話は直接は関係なくてもジワジワ効いてくる話だと思う。p319-p321</p>
<h2 id="仮置場">仮置場</h2>
<h3 id="プロトコル">プロトコル</h3>
<p>fluent pythonを読んでいて、用語集に「プロトコル」がないのが気になっている。ガンガン用語として使っているのに、はっきりと説明せずに外堀を埋める形で、定義しようとしている感じです。</p>
<p>fluent python P317の「非形式的なインターフェースとしてのプロトコル」という文章があった。ようやく著者の意図が説明されてすっきり、やっぱり用語集に入れておく価値があると思うな。本に書き込むか、私的用語集にぶっこんでおくのがいいんだろうな。</p>
<p>pythonと、「トレイト」について調べていると、たまたま見つかった文書 <a href="https://qiita.com/t2y/items/434854fab16159a7c0f7">[翻訳] Python プログラマーのための Rust 入門 - Qiita</a> があって、「トレイト対プロトコル」という見出しがある。</p>
<blockquote>
<p>Python では、特殊メソッドを実装することでクラスは特定の振る舞いを選択できます。これは通常 &ldquo;プロトコルに従う&rdquo; と呼ばれます。</p>
</blockquote>
<p>この表現は、現段階でfluent pythonを読み進めていてしっくりとくる表現です。特殊メソッドは、ダンダともいうので、同じことを別の名前で表していることがあるので、「本を読む本」のいう「シントピカル読書」が有効だというのも納得です。多分簡単過ぎる表現にすると、間違った理解に至るのを嫌っているから、こういうやり方なのかも知れない。</p>
<p>こうやって自分で、調べていくと忘れないからいいけど。</p>
<p>トレイトに関しては、「コーディングを支える技術」を参照してほしい。ScalaやSqueakの例があるとのこと。上記linkで Rust も。</p>
<h3 id="ジェネリック">ジェネリック</h3>
<p>言葉としてはよく聞くが、具体的な定義なしにフワッと使っていないか?読み落としているだけかもしれないが。動的言語なので、どのクラスに入っても有効に使える関数として書くという意味であれば、下記のmixinに近接した概念になるのではないか。下のmix-inも参照せよ。</p>
<h3 id="mix-in">mix-in</h3>
<ul>
<li>
<p><a href="https://www.atmarkit.co.jp/ait/articles/1909/03/news021.html">［Python入門］多重継承とmixin (1/2)：Python入門 - ＠IT</a></p>
<ul>
<li>多重継承すると、何が問題となるか。、別のクラスの変数は、同じ名前で、同じクラスに入れても「別の変数」である。</li>
<li>あ、ここの説明は、継承関係は派生した側(下側)から、親に向かって矢印を引く流儀や。</li>
<li>mixinっていうても、継承の使い方で、「特別なキーワード」をつけて別の呼び方をしている訳じゃない。</li>
<li>mixin側は、self経由でごにょごにょするコードを書く。ここの意味が、Effective pythonのp74にある「Pythonでは、mix-inを書くのが容易です。それは、型にかかわらず現在の状態を調べるのが簡単にできるからです。動的インスペクションのおかげで、他の多くのクラスにも適用できるジェネリックな機能をmix-inで一度に書くことができるのです。」ということで、Pythonでいうジェネリックという概念は、この意味であると仮に理解しておく。後でまた変えるかも。</li>
<li>クラス階層という言葉があり、mix-inは、どのクラス階層にも入れることができるとあるが、これって、「どこのクラスにも入れることができるように書いている」から、できるのであってなんかトートロジーな説明ではないか。とも思える。</li>
</ul>
</li>
<li>
<p><a href="https://www.atmarkit.co.jp/ait/articles/1909/03/news021_2.html">［Python入門］多重継承とmixin (2/2)：Python入門 - ＠IT</a></p>
<ul>
<li>なるほど、mix-inしたクラスで、テンプレートメソッドという言葉を出している。が、これって abstraction  している部分と、implementation しているのを分けているともいえるので、同じことを別の名前で呼んでいる可能性もあるのでは。さしずめオーバーライドが、インプリメンテーションってか実装、か。ルー大柴っぽくカタカナ語が多いが、多分そういうことか。</li>
<li>自分で実装しろよ。というやり方もこれね。</li>
<li>最後まで読むのは会員登録がいるが、ここまで書いてあれば、なんとかなるか。</li>
<li>ってか、Effective Pythonの「項目24:@classmethnodポリモルフィズムを使ってオブジェクトをジェネリックに構築する」p64-69 に収斂していくのでは、クラスで実装するパターンとして。</li>
</ul>
</li>
</ul>
<dl>
<dt>「コーディングを支える技術」</dt>
<dd>「12.3 多重継承の問題点」- 解決策3:処理を混ぜ込む(Mix-in) pythonの場合 p230 言語的なサポートを受ける、受けない。慣習としての話がある。Pythonは多重継承できるので、「コーディングを支える技術」の 12.2 多重継承 「実装の再利用に便利な多重継承」p219を挙げておく。<!-- raw HTML omitted -->「コーディングを支える技術」12.2多重継承の問題点&mdash;またしても衝突! 「提供するメソッドと要求するメソッド」p233において、書いてある問題点として、 <strong>Mix-inをする場合に、単体ではインスタンス化してはいけないクラスがあるが、どういう状態になればインスタンスを作っていいか判別する仕組み言語上のサポートがない</strong> というものでした。</dd>
</dl>
<h3 id="effctive-python">effctive python</h3>
<p>もう第二版が出ているので、初版の正誤表はなくなったのかもしれんが、索引の mix-in クラス　の　定義が、73-74は間違っていないか
多分、74-75ではないのか。</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>ダンダーの話は、p4に載っています。 <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>p85の下から1行目 <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>誤解させる言い方ですね。正確には、低レベルのレイヤを対象する技術者、アセンブラ/C言語でのシステムプログラミング以下、組み込み系とか、OSとかを触る感じの人です。 <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>REPLのことをコンソールセッションと呼び、関数を「ランタイム」で生成しているので、実行可能バイナリのことを指してランタイムと呼んでいるわけではなさそうです。 <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>LISPの話? <a href="https://code.i-harness.com/ja-jp/q/91c501">clojure - common lisp wikipedia - 解決方法</a> や一般的には、<a href="https://ja.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E3%83%87%E3%82%A3%E3%82%B9%E3%83%91%E3%83%83%E3%83%81">多重ディスパッチ - Wikipedia</a> とも呼ぶようだ。 <a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>識別子というか、このIDって実装依存なんや。 <a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

  </section>

  <section>
    
      
    
  </section>
</article>

      </div>

      <div id="side" class="pr-1 bg-white">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>Fluent Python 読書メモ</b><nav id="TableOfContents">
  <ul>
    <li><a href="#はじめに">はじめに</a></li>
    <li><a href="#対象としている読者">対象としている読者</a>
      <ul>
        <li><a href="#知っていた方がいいこと">知っていた方がいいこと</a></li>
      </ul>
    </li>
    <li><a href="#点検読書i">点検読書I</a>
      <ul>
        <li><a href="#この本は何について書いたものであるか">「この本は何について書いたものであるか」</a></li>
        <li><a href="#この本はどのように構成されているか">「この本はどのように構成されているか」</a></li>
        <li><a href="#どのような部分に分けられているか">「どのような部分に分けられているか」</a></li>
        <li><a href="#この本はどういう種類の本か">「この本は、どういう種類の本か」</a></li>
      </ul>
    </li>
    <li><a href="#1章-pythonのデータモデル">1章 Pythonのデータモデル</a>
      <ul>
        <li><a href="#11-pythonicなトランプ">1.1 Pythonicなトランプ</a></li>
        <li><a href="#疑問点">疑問点</a></li>
        <li><a href="#読書会で話題になったこと">読書会で、話題になったこと。</a></li>
      </ul>
    </li>
    <li><a href="#2章-シーケンスの配列">2章 シーケンスの配列</a>
      <ul>
        <li><a href="#21-組み込み型シーケンスの概要">2.1 組み込み型シーケンスの概要</a></li>
        <li><a href="#22-リスト内包表記とジェネレータ式">2.2 リスト内包表記とジェネレータ式</a></li>
        <li><a href="#24-スライス">2.4 スライス</a></li>
        <li><a href="#27-listsortと組み込み関数-sorted">2.7 list.sortと組み込み関数 sorted</a></li>
        <li><a href="#28-bisectを使った順序付きシーケンスの処理">2.8 bisectを使った順序付きシーケンスの処理</a></li>
        <li><a href="#29-listを使わない方がよいケース">2.9 listを使わない方がよいケース</a></li>
        <li><a href="#210-本章のまとめ">2.10 本章のまとめ</a></li>
        <li><a href="#211-参考文献">2.11 参考文献</a></li>
      </ul>
    </li>
    <li><a href="#3章-ディクショナリとセット">3章 ディクショナリとセット</a>
      <ul>
        <li><a href="#31-一般的なマップ型">3.1 一般的なマップ型</a></li>
        <li><a href="#32-ディクショナリ内包表記">3.2 ディクショナリ内包表記</a></li>
        <li><a href="#一般的なマップメソッドの概要">一般的なマップメソッドの概要</a></li>
        <li><a href="#331-存在しないキーをsetdefaultで処理">3.3.1 存在しないキーをsetdefaultで処理</a></li>
        <li><a href="#34-柔軟なキー検索を使ったマップ">3.4 柔軟なキー検索を使ったマップ</a></li>
        <li><a href="#35-dictのバリエーション">3.5 dictのバリエーション</a></li>
        <li><a href="#36-userdictのサブクラス化">3.6 UserDictのサブクラス化</a></li>
        <li><a href="#37-不変マップ">3.7 不変マップ</a></li>
        <li><a href="#38-セット">3.8 セット</a></li>
        <li><a href="#39-dictとsetの内部構造">3.9 dictとsetの内部構造</a></li>
        <li><a href="#310-本章のまとめ">3.10 本章のまとめ</a></li>
        <li><a href="#311-参考文献">3.11 参考文献</a></li>
      </ul>
    </li>
    <li><a href="#4章-テキストとバイト">4章 テキストとバイト</a>
      <ul>
        <li><a href="#41-文字の問題">4.1 文字の問題</a></li>
        <li><a href="#42-バイトについて">4.2 バイトについて</a></li>
        <li><a href="#43-基本的なエンコーダとデコーダ">4.3 基本的なエンコーダとデコーダ</a></li>
        <li><a href="#44-エンコードとデコードの問題点">4.4 エンコードとデコードの問題点</a></li>
        <li><a href="#45-テキストファイルの処理">4.5 テキストファイルの処理</a></li>
        <li><a href="#46-適切な比較のためのunicodeの正規化">4.6 適切な比較のためのUnicodeの正規化</a></li>
        <li><a href="#47-unicodeテキストのソート">4.7 Unicodeテキストのソート</a></li>
        <li><a href="#48-unicodeデータベース">4.8 Unicodeデータベース</a></li>
        <li><a href="#49-strbytes-デュアルモードapi">4.9 str/bytes デュアルモードAPI</a></li>
        <li><a href="#410-本書のまとめ">4.10 本書のまとめ</a></li>
      </ul>
    </li>
    <li><a href="#5章-第一級関数">5章 第一級関数</a>
      <ul>
        <li><a href="#51-関数をオブジェクトのように扱う">5.1 関数をオブジェクトのように扱う</a></li>
        <li><a href="#52-高階関数">5.2 高階関数</a></li>
        <li><a href="#53-無名関数">5.3 無名関数</a></li>
        <li><a href="#54-7つの呼び出し可能オブジェクト">5.4 7つの呼び出し可能オブジェクト</a></li>
        <li><a href="#55-呼び出し可能なユーザ定義型">5.5 呼び出し可能なユーザ定義型</a></li>
        <li><a href="#56-関数のイントロスペクション">5.6 関数のイントロスペクション</a></li>
        <li><a href="#510-関数型プログラミングのためのパッケージ">5.10 関数型プログラミングのためのパッケージ</a></li>
      </ul>
    </li>
    <li><a href="#6章-第1級関数を使ったデザインバターン">6章 第1級関数を使ったデザインバターン</a>
      <ul>
        <li><a href="#61-リファクタリングのケーススタディとしての-strategy-パターン">6.1 リファクタリングのケーススタディとしての Strategy パターン</a></li>
        <li><a href="#command-パターン">Command パターン</a></li>
        <li><a href="#63-本章のまとめ">6.3 本章のまとめ</a></li>
        <li><a href="#64-参考文献">6.4 参考文献</a></li>
      </ul>
    </li>
    <li><a href="#7章-関数デコレータとクロージャ">7章 関数デコレータとクロージャ</a>
      <ul>
        <li><a href="#71-デコレータの基礎">7.1 デコレータの基礎</a></li>
        <li><a href="#72-デコレータ実行のタイミング">7.2 デコレータ実行のタイミング</a></li>
        <li><a href="#73-デコレータを使った-strategy-パターンの改善">7.3 デコレータを使った Strategy パターンの改善</a></li>
        <li><a href="#74-変数スコープ">7.4 変数スコープ</a></li>
        <li><a href="#75-クロージャ">7.5 クロージャ</a></li>
        <li><a href="#76-nonlocal宣言">7.6 nonlocal宣言</a></li>
        <li><a href="#77-シンプルなデコレータの実装">7.7 シンプルなデコレータの実装</a></li>
        <li><a href="#78-標準ライブラリのデコレータ">7.8 標準ライブラリのデコレータ</a></li>
        <li><a href="#79-多重デコレータ">7.9 多重デコレータ</a></li>
        <li><a href="#710-パラメータ化デコレータ">7.10 パラメータ化デコレータ</a></li>
        <li><a href="#711-本章のまとめ">7.11 本章のまとめ</a></li>
        <li><a href="#712-参考文献">7.12 参考文献</a></li>
      </ul>
    </li>
    <li><a href="#8章-オブジェクト参照可変性リサイクル">8章 オブジェクト参照、可変性、リサイクル</a>
      <ul>
        <li><a href="#81-変数--箱">8.1 変数 != 箱</a></li>
        <li><a href="#82-同一性等価性エイリアス">8.2 同一性、等価性、エイリアス</a></li>
        <li><a href="#83-デフォルトのコピーは浅い">8.3 デフォルトのコピーは「浅い」</a></li>
        <li><a href="#84-参照としての関数の引数">8.4 参照としての関数の引数</a></li>
        <li><a href="#85-delとガベージコレクション">8.5 delとガベージコレクション</a></li>
        <li><a href="#86-弱参照">8.6 弱参照</a></li>
        <li><a href="#87-pythonが不変型で使っている魔術">8.7 Pythonが不変型で使っている魔術</a></li>
        <li><a href="#88-本章のまとめ">8.8 本章のまとめ</a></li>
        <li><a href="#89-参考文献">8.9 参考文献</a></li>
        <li><a href="#soapbox">Soapbox</a></li>
      </ul>
    </li>
    <li><a href="#9章-pythonic-なオブジェクト">9章 Pythonic なオブジェクト</a>
      <ul>
        <li><a href="#91-オブジェクトの表現">9.1 オブジェクトの表現</a></li>
        <li><a href="#92-vectorクラス再訪">9.2 Vectorクラス再訪</a></li>
        <li><a href="#93-別バージョンのコンストラクタ">9.3 別バージョンのコンストラクタ</a></li>
        <li><a href="#94-classmethodとstaticmethod">9.4 classmethodとstaticmethod</a></li>
        <li><a href="#95-出力フォーマット">9.5 出力フォーマット</a></li>
        <li><a href="#96-ハッシュ可能なvector2d">9.6 ハッシュ可能なVector2d</a></li>
        <li><a href="#97-プライベート属性とプロテクト属性">9.7 プライベート属性と「プロテクト」属性</a></li>
        <li><a href="#98-クラス属性-__slots__-によるメモリ節約">9.8 クラス属性 __slots__ によるメモリ節約</a></li>
        <li><a href="#99-クラス属性の上書き">9.9 クラス属性の上書き</a></li>
        <li><a href="#910-本章のまとめ">9.10 本章のまとめ</a></li>
        <li><a href="#911-参考文献">9.11 参考文献</a></li>
        <li><a href="#soapbox-1">Soapbox</a></li>
      </ul>
    </li>
    <li><a href="#10章-シーケンスをばらしてハッシュしてスライスする">10章 シーケンスをばらして、ハッシュして、スライスする</a>
      <ul>
        <li><a href="#101-ユーザ定義のシーケンス型vector">10.1 ユーザ定義のシーケンス型(Vector)</a></li>
        <li><a href="#102-vector2d互換vectorテイク1">10.2 Vector2d互換(Vectorテイク1)</a></li>
        <li><a href="#103-プロトコルとダックタイピング">10.3 プロトコルとダックタイピング</a></li>
        <li><a href="#104-スライス可能てシーケンスvectorテイク2">10.4 スライス可能てシーケンス(Vectorテイク2)</a></li>
        <li><a href="#105-動的な属性アクセスvectorテイク3">10.5 動的な属性アクセス(Vectorテイク3)</a></li>
        <li><a href="#106-ハッシュとより高速なvectorテイク4">10.6 ハッシュとより高速な==(Vectorテイク4)</a></li>
        <li><a href="#107-フォーマットvectorテイク5">10.7 フォーマット(Vectorテイク5)</a></li>
        <li><a href="#108-本章のまとめ">10.8 本章のまとめ</a></li>
        <li><a href="#109-参考文献">10.9 参考文献</a></li>
        <li><a href="#soapbox-2">Soapbox</a></li>
      </ul>
    </li>
    <li><a href="#仮置場">仮置場</a>
      <ul>
        <li><a href="#プロトコル">プロトコル</a></li>
        <li><a href="#ジェネリック">ジェネリック</a></li>
        <li><a href="#mix-in">mix-in</a></li>
        <li><a href="#effctive-python">effctive python</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
  

  
    
    
      <div>
        
          <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
        

        
          <iframe src="https://www.facebook.com/plugins/share_button.php?href=https%3A%2F%2Fdevelopers.facebook.com%2Fdocs%2Fplugins%2F&layout=button&size=small&mobile_iframe=true&width=61&height=20&appId" width="61" height="20" style="border:none;overflow:hidden" scrolling="no" frameborder="0" allowTransparency="true" allow="encrypted-media"></iframe>
        

        
          <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="basic-label-counter" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
        

        
          <a data-pocket-label="pocket" data-pocket-count="none" class="pocket-btn" data-lang="en"></a>
          <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
        

      </div>
    
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 bg-white text-center">
        

  <span class="text-small text-gray">
    ©YABUKI Yukiharu 2020 &middot; 

    Powered by the
    <a href="https://github.com/qqhann/hugo-primer" class="link-gray-dark">Hugo-Primer</a> theme for
    <a href="https://gohugo.io" class="link-gray-dark">Hugo</a>.
  </span>


      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
    
  </body>
</html>
