---
title: "Fluent Python 読書メモ"
date: 2020-07-10T07:27:29+09:00
author: yabuki
draft: false
Categories:
- 読書メモ
tags:
- Python
- FluentPython
keywords:
---

## はじめに

Fluent Pythonを読むにあたって、「本を読む本」のなかで問われている問いに答える形で、読書メモを作っていこうと思う。

1. 「初級読書」 --- これは、「その文は何を述べているか」を確認するのであるが、誤読していることもあるので侮れない。まま、このレベルに戻ることもあろう。
    1. 「読み方準備期」
    1. ごく簡単な読み方を覚える
    1. 文脈をたどって知らない単語の意味をつかむ。
    1. 1つの作品から得た概念を消化して次の書籍を読む。1つの主題について幾人かの著者が述べることを比較することができるようになる。(ここに至ることができないこともある)
1. 「点検読書」 ---  時間に重点を置いて、「系統だって拾い読み」をする技術を指す。今回は、緩急を付けて読んでいるので、これに該当するとおもう。
    * 「この本は何について書いたものであるか」
    * 「この本はどのように構成されているか」
    * 「どのような部分に分けられているか」
    * 「この本は、どういう種類の本か」
1. 分析読書
1. シントピカル読書」(他の本と比較しつつ読む)

と、「批判的読書のコツ 20のポイント」も押さえたい。あと、分析読書をいうか、内容を噛み砕く時の手がかり、足がかりのメモも残したい。

## 対象としている読者

page xiiにある。

python以外から、pythonを書くようになったプログラマーが、これまで培ったプログラミングのノウハウを越えて、**「pythonらしい」** プログラムを書きたい場合に参照する本であり、python3を使いこなしたい人向けであるとのこと。

一定以上pythonを理解している必要があるので、読者はオススメしてあるドキュメントやチュートリアルをやっておく必要があるかもしれない。

また、python初心者がこの本を読むと、なんでもこの本に書いてあることを実践したくなるので、止めた方がいいともある。知っていて使わないという選択ができないと有害でもある。

----

*yabuki (注)*

読み進めるにつれて、対象の読者は、pythonの一通りについて分かっていて、用語もばっちりokという感じでないと、ふんふんと読み進めることは厳しいかも。こうやって読書メモを作る習慣がないと読みきるのも辛いかも。一人じゃなくて仲間で分担したほうがいいね。

それか、分からないことを調べるのをグッと我慢して、ある程度読み進めてから目星う付けて調べるでもいいか。うまく緩急を付けるのがコツか。

### 知っていた方がいいこと

* REPL --- 対話型コンソールについては、ちょっとしたプログラムを動かすのに便利だ。
* doctest

あと、紙の本に落とす時にリンクは別にしてあるという方針なので、こうやって自分なりにそのlink集を再現した方が理解がしやすくなると思う。オンライン・ドキュメントを読んで理解が深まるなら作業は増えても、うんうん唸る時間は減る。

#### 用語集

本文を読む前にざっとでいいから目を通しておくと、どの言葉が用語集にあるのか分かってよい。紙の文書だから、使っている用語をそのままハイパーリンクにできないのでこうしているのだと思うけど。


用語集が p711 からある。私のように用語の定義というか何を指しているのかを知りたがる人は先に目を通しておこう。 2020-07-12 の 06:10 時点で4章以前の疑問に思ったことはだいたい書いてある。最初から気がついていたら時間の節約もそうだし、悩む必要がなかった。

あと、本家の用語集(の日本語版)も目を通しておけとのこと。

- [用語集 — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/glossary.html)

## 点検読書I

### 「この本は何について書いたものであるか」

 (最後まで読み切れていないが、暫定版として)この本は、pythonの持っている力を引き出すメンタルモデルと、プログラミング方法について書いた本である。

### 「この本はどのように構成されているか」

まえがきのページ xii からの書いてある。拾い読みをするときに、いいガイドになるかも知れません。ただ、理解するには前に遡って読む必要があるかもしれません。

#### I部
#### II部
#### III部
#### IV部
#### V部
#### VI部


### 「どのような部分に分けられているか」

### 「この本は、どういう種類の本か」

pythonの能力を引き出す方法、pythonic? な方法について書いた本

## 1章 Pythonのデータモデル

pythonのデータモデルについて説明なしに知っている前提で書いています。ひとまずいろいろ棚上げして、辛抱強く最後まで読むとなんとなく分かります。一緒に、[3.データモデル](https://docs.python.org/ja/3.7/reference/datamodel.html)とか眺めておくといいかもしれません。

データモデルとは、何ぞやというのは、別の本でちゃんと定義されているのかもしれません。この章を読むと書いてある内容からなんとなく、「データモデル」とよんでいる物が、Pythonの根幹を為す、ダンダー[^ダンダー]についての話なんだなって。

Soapbox の、「データモデル?それともオブジェクトモデル?」で、もう少しヒントがでてくる。


Soapboxでは、他にjsとjavaの話がでてる。p16からp17にかけて。

lenがメソッドでないのは、そうとう議論になったから何度も出てくるんだろうね。やはり。

[^ダンダー]: ダンダーの話は、p4に載っています。

### 1.1 Pythonicなトランプ

- [collections --- コンテナデータ型 — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/library/collections.html?highlight=namedtuple#collections.namedtuple)

- 2〜10,J,Q,K,Aの配列
- namedtupleの利点は、固有のメソッドを持たないオブジェクトをのクラスを作れるようになった。以下は矢吹の推測だが、なんでもオブジェクトだとやりすぎで、シンプルなデータ構造を作ってメモリの有効活用をしたかったのではないか。

シントピカル読書
: Effective Pythonのp59で、namedtupleの限界というコラムがある。有用な場合と害の場合がある。とのこと。

### 疑問点

* Pythonのデータモデルとは、どのように説明したらいいのか。

### 読書会で、話題になったこと。

chatに貼り付けてもらったとか、話題にでたのを主に書き残しておく。

- Python 入門ノート
- [Python実践入門 ──言語の力を引き出し、開発効率を高める：書籍案内｜技術評論社](https://gihyo.jp/book/2020/978-4-297-11111-3)
- [Python Online | Online editor and compiler](https://paiza.io/en/projects/new?language=python3)
- [namedtupleで美しいpythonを書く！（翻訳） - Qiita](https://qiita.com/Seny/items/add4d03876f505442136)
    - namedtuple使いでがあるよね。って話
- DataClassも使いでがあるよね。いま読んでいるFluentPython日本語版は、主にpython3.3までの話題を取り扱っているので、DataClassの話はでてこないけど、discordのpythonコミュニティで話題になっていた。という話
    - [Pythonjp Discord Server](https://www.python.jp/pages/pythonjp_discord.html)
- pylanceの話題。
- 用語集は先に読んでおくといいね。
- 使っているpythonの開発環境の話題。ice breakにはいいかもね。
- Fluent Pythonのサンプルプログラムのライセンスは、MITであるとのこと。
    - [example-code/LICENSE at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/LICENSE)
    - [fluentpython/example-code: Example code for the book Fluent Python](https://github.com/fluentpython/example-code)
- [example-code/frenchdeck.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/01-data-model/frenchdeck.py)
- [example-code/vector2d.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/01-data-model/vector2d.py)

## 2章 シーケンスの配列

pythonに関係深い、ABCという言語の話が導入となる。

シーケンスって、なんだったかな。と、Python ボケットリファレンスの113pを参照しておく。クラス図からの説明になる。きっちりと言葉で説明するのは難しいが、こうやってクラス図で表されると何となくわかる。でも他人に説明できるかと言われると多分できない。

データの入った物が一列に並んでいるイメージを想定してください。って感じか。コンテナが並んでいる感じ。

### 2.1 組み込み型シーケンスの概要

で、シーケンスとはなにか?については既知として、分類から概要が始まる。

- コンテナ・シーケンス
- フラット・シーケンス

p22を参照。参照が入るか、実体のデータたちがはいるか。それぞれに、メリットとデメリットがある。

別の分け方として、

- mutable sequence
- immutable sequence

可変なシーケンス、不変なシーケンスという日本語がわりあたっているが、昨今ではカタカナの方が通りがよかったりする?そして書き換えができるか、できないか。の違いなので、自分のイメージにひきつけて理解することにした。

そして、図2-1 この図に見慣れないと、後から混乱しそう。向かって右が、子で、向かって左が、親の関係か。ここでは子から親に矢印が向かっている。と理解した。p23

### 2.2 リスト内包表記とジェネレータ式

シーケンスを作る手段として、リスト内包表記と、ジェネレータ式に言及じている。「読みやすくて速い」という著者の主張を読み進めることになる。

下記は省略語として、

- listcomp : リスト内包表記
- genexp : ジェネレータ式

という表現を知る。

- [ord 組み込み関数 — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/library/functions.html#ord)
    - 与えられたシンボルのコードを出力する。p24

p24の構文のヒントは役立った。ここで改行していいってのは、コードを見てなんとなくは分かっていたが文章で書いてもらえるのはありがたい。

p25のコラムは、python3の世界になったので、今となっては、python2のコードを書く必要がないかぎり忘れて良いのではないか。

#### 2.2.2 リスト内包表記とmap/filterの違い

pythonのlambdaか、機能的に足りないとは?　別の場所で言及はあるか。あと、何と比較して足りる足りないを著者は語っているのか。

例2-3のコードが、リスト内包表記とmap/filterで書いたコードを比較している。若干慣れの気がするかもしれないが、実行速度を比較するコード listcomp_speed.py があるので、差が分かるぐらいに違うんだろう。


#### 2.2.3 デカルト積

デカルト積という名前に、不安を抱く必要は無い。数学の順列・組み合わせを思い出せば良いみたい。または行列の積

#### 2.2.4 ジェネレータ式

全部を一度に作らなくても、実行するたびに値を返せば、使用メモリーを減らすことができるのは道理だ。

あと、ポケットリファレンスでは、yield文を使う例しか出てこなかったが、ここでは違う書き方があるで勉強になる。

#### 2.3.1 レコードとしてのタプル

RDBをよく使っていると、レコードというと、RDBで処理したらいいじゃないか。と、してしまいそうになるが、ここで書いてあるテクニックは、pythonらしい書き方というか、データ操作方法になると思う。ある程度データが大きくなるまではRDBへの依存がないプログラムの方が扱いが楽だし。依存を増やすのは後からでもできる。

#### 2.3.2 タプルのアンパック

ここでの、アスタリスクの使い方は、おまじないだとして引数などに付けていた、アスタリスクが、vividに意味を持ち始めた。あとタプルの値のスワップに、一時変数を使わなくても良いってのは、C言語からすると楽ではあるが、ちょっと落ち着かない。(内部ではちゃんとしているだろうから便利に使わせてもらうのてはある)


\_ は、文法でなく慣習であるというのは、前に調べていたのでよかった。また i18n への言及があるのは良い。ただ、これだけではない。p32

#### 2.3.3 ネストしたタプルのアンパック

ちょっとしたRDBの問い合わせみたいなことをここでは、タプルとアンパックを使って実現してる。p33

#### 2.3.4 名前付きタプル

僅かなメモリの増加を受け入れると、名前付きのタプルでこんな便利なことができるよ。と教えてくれる。プログラムをを書くにあたって確かに明確に意志を伝えるプログラムを書くことができるので使いたくなる。

本の範囲は外れるが、 python3.7からは、　[dataclasses --- データクラス — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/library/dataclasses.html) とかもあるのでデータを扱う引き出しが増えるので、ここにメモっておく。

#### 2.3.5 不変リストとしてのタプル

不変リスト = immutable

listとtupleの似ている点について、どこまで一緒なのかを確認すると違う部分に集中できるので良さそう。p35からp36

### 2.4 スライス

ここで扱うのは、python本体と一緒に配布されているライブラリの使い方であり、自分で同じような動作をするクラスを作るのは、第10章で扱うとのこと。

ここでは、あんまりできると思っていなかった使い方を知る。ごちゃごちゃ書かずにスパッとデータを書き換える方法がある。p39

NumPyと、SciPyについては、例外として言及している。p38


#### 2.5.1 リストのリストの生成

ここは、実体を回数分生成しているのか、参照を回数分生成しているのか。を、必要な時には思い出したい。p41


#### 2.6.1 +=による代入の謎

へー。としか。確かにコーナーケースである。

- [python tutor](http://www.pythontutor.com/live.html#code=t%20%3D%20%281,2,%20%5B30,40%5D%29%0At%5B2%5D%20%2B%3D%20%5B50,60%5D%0A&cumulative=true&curInstr=2&heapPrimitives=true&mode=display&origin=opt-live.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false)
    - pythonのlive programmingモードにしておく。

- byte codeを吐き出すのに、 [dis --- Python バイトコードの逆アセンブラ — Python 3.8.4rc1 ドキュメント](https://docs.python.org/ja/3/library/dis.html) を参照すること。`import dis`をしないとエラーになる。

### 2.7 list.sortと組み込み関数 sorted

Noneが返ると、chain methodにならない。逆説的に、chain methodを作る方法とするのがいいか。p45

### 2.8 bisectを使った順序付きシーケンスの処理

大量のデータから、できるだけ速く該当のデータを探し出すために、あるキー順にソートしてある前提でデーさ操作をすることがある。

身近な例でいうと、git bisect がキーワードとして似ているし、二分木探索の話はどのアルゴリズムの本なら触れているだろう。これまで読んだ本でおもしろかったのは、debugに、2分木法を使うという本を読んだときであった。

### 2.9 listを使わない方がよいケース

こいつ使って、いつ使わないかも知りたかった、

#### 2.9.1 配列

ここも読む価値がある。

#### 2.9.2 メモリービュー

Cのstructとunionの合わせ技みたいなことができるんや。

例 2-21に対するメモ
```bash
% echo "obase=16;ibase=10;1024"|bc
400
```

#### 2.9.3 NumPyとSciPy

この本では、基本的にはPythonに付属のライブラリの話をしているが、ここではタイトルの用に、NumPyとSciPyを扱う。

私は、Debian GNU/Linuxを使っており、お手軽に導入するため、`apt install python3-numpy python3-scipy`のコマンドで導入した。

#### 2.9.4 デックやその他のキュー

appendやpopメソッドを使えば、スタックやキューとして使えるし、inque,dequeについても書いてある。スレッドセーフなのが嬉しい。

ここも、スレッドセーフ、プロセス間通信、asyncioに対応した。queue関係の情報かある。そしてheapqがあるので一から作らなくても、シーケンスをヒープキューや優先順序付きのキューを提供してくれるとのことで、自分で書いてデバッグする時間を減らすことができそう。

### 2.10 本章のまとめ

一度読んでおけば、ここから情報を取るだけで思い出せることが増えて良さそう。p61-p62

### 2.11 参考文献

ここは、また戻ってきた時に参照する。一回目は軽くなぞるだけにする。

Soapboxの「すばらしいkey」については、心惹かれた。

## 3章 ディクショナリとセット

この章は、最初に概要を書いてくれている。良い。

pythonを使っていて、辞書(ディクショナリ/dict)型を使わないことはない。と言いきってもいいぐらい。ユーザーが作っているプログラムで多用されているだけでなく、

- モジュールの名前空間
- クラスとインスタンスの属性
- 関数のキーワード引数

などのpythonを支えている機能は、dict型で実装されている。これらはハッシュテーブル
で作られていることが明かされる。

この章では、ハッシュテーブルの仕組みを解説することで、pythonのdictとsetを活用する方法を学ぶことができるとある。

### 3.1 一般的なマップ型

map型とは一体 :thinking face: なりながら、読み進める。

- [collections --- コンテナデータ型 — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/library/collections.html)
    - 話は逸れるが、このへんは見ておこう。

- [collections.abc --- コレクションの抽象基底クラス — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/library/collections.abc.html#module-collections.abc)
    - 本命はこっち、以前は上記と一緒だったが、python3.3で分かれた。

p70の図3-1

Mappingと、MutableMappingの継承について書いてあるから、これがmap型の説明なんだと思う。言葉でなく、UML図で示す感じ。どういうメンバーというかメソッドがいるのか、ってのを理解するのはこっちの方がまどろっこしくないからいいのか。

特殊用途のマップの実装について、ここに記述がある。「抽象基底クラス」ではなく、dictまたは、collections.UserDictを拡張することについて書いてある。

dict型かどうかを検査するより、isinstanceを用いよ。という話

「ハッシュ可能とは」というコラムはp70からp71 オブジェクト比較の話だが、比較できない場合について述べてあるので、いつ使えて、いつ使えないのかを確認するために参照することになるかも。内部状態という概念は得た。

- [組み込み型 — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/library/stdtypes.html#mapping-types-dict)
    - 文書の中で言及しているは、この部分である。
    - ここの文書も一階層あがって読みきったから、この本書いているんだろうな。
    - 日本語版をpointしているので、4. Built-in Typesかどうかは見てない。例が同じそうだ。というのは軽く確認した。

### 3.2 ディクショナリ内包表記

リスト内包表記があるなら、ディクショナリも同じような書き方ができると類推できるよね。ってことか。p72

### 一般的なマップメソッドの概要

ここでも出てくるAPIという言葉。メソッドと何が違うのか、最初で定義しているのに読み飛ばしたかなと思えてきた。

ここの表も必要があれば参照したくなるだろう。dict,defaultdict,OrderedDictの差がわかる。

### 3.3.1 存在しないキーをsetdefaultで処理

ここで、「フェールファースト」の理念が出てくる。私はあんまり聞いたことがなかったので、監訳者の注で意味が補われていて予想した意味と異なっておらず助かった。ダックタイピングはけっこう聞くのでそこは気にならず。

この、setdefaultに関しては、持っているPythonポケットリファレンスの、P154 「9-3-8 デフォルト値付きの抽出」で、大まかな内容を知っているので、細かく挙動を書いてあるぽいことだけ確認した。

p75-o75 まずは、setdefaultを使わない方法を示して、p76で、setdefaultを使って解きなおししている。

### 3.4 柔軟なキー検索を使ったマップ

サーチしたキーが、存在しなかった時に、どういう扱いがいいかについて、2つの方法を提示している。

1. dictの代わりに、defautldictを使う
2. サブクラスを作って、\_\_missing\_\_ メソッドを追加する。

#### 3.4.1 defaultdict --- 存在しないキーの扱い方 その1

ここでは、サーチして最初に見つかったときに、エントリーを生成するプログラムを例として説明している。ようするに、KeyErrorを発生させない。

p78 のいつ呼び出されて、どういうときに呼び出されないか。は押さえておきたい。

#### 3.4.2 \_\_missing\_\_ メソッド --- 存在しないキーの扱い方 その2

\_\_missing\_\_ の定義の方法と、どのタイミングで、呼び出されるのかについて記述してある。これ、pythonの基礎的なメカニズムなんで、後から広く応用できるんではないだろうか。rubyのmissing\_methodのように。読み進めると分かるか。

これについても、何時使えて、いつ使えないのか書いてあるので、ここは後からも参照しそうな感じ。p78

\_\_missing\_\_ の実装で、isinstance のチェックが必要な理由についても読んでおきたい。

### 3.5 dictのバリエーション

- collections.OrderedDictの説明 p81
    - 挿入された順、デフォルトはqueueのような動作だが、stackのような動作をさせることもできる。
- collections.ChainMap の説明 p81
    - 複数のマップを一括でサーチできる。サクッと作って後からチューニングするのに便利そう。どう使うかの例は書いてある。
- collections.Counter の説明 p82
    - 最頻をカウントするのに便利そう。いくつか便利そうなメソッドも紹介している。
- collectgions.UserDict
    - 次の 3.6 で説明とのこと。

### 3.6 UserDictのサブクラス化

こっちを使う方が便利なんじゃないかなっていう指針を教えてくれる。UserDicTを使う前には、読んでおくとハマらずに短い時間でプログラムを作れそう。

### 3.7 不変マップ

immutable map 何時使うのか。についてはアイディアや必要性に迫られた時でいいか。その時に細かく読めば良いか。

### 3.8 セット

ポケットリファレンスのP155からp156にざっくりと書いてあるのを復習してからこの 3.8 を読む。

setについて。記述が古いのかあんまり使われていないとあるが、ハマると便利なんで使いこなしたい。classとしての、setとfrozenset

- 重複した要素を許さない。
    - これは、RDBの一意制約にも似て、使いでがある制約に感じる。
    - 本文中の「重複する要素を削除することが」[^重複する要素を削除することが]ってのは、結果としてそうなる。という意味に取らないと削除する動作を何時するんだってなりそう。
- Setの要素は、ハッシュ可能であること。Set自体はハッシュ不可能、Frozensetはハッシュ可能なので、Setの要素に、Set自身は使えないが、Froaensetは使える。
- このへんになってくると、数学の集合論を利用したくなるね。集合論的な操作できるし。ループや条件分岐を減らせるのは、コードが短くなって間違いの余地が減りそう。

[^重複する要素を削除することが]: p85の下から1行目

#### 3.8.1 リテラル

Setの構文で、だいたい数学と一緒なんだけど、空集合だけは別の書き方をするぜ。{}とかくと、意図に反して空のdictができてしまう。これって、間違えないようにする工夫はあるだろうか。型?

リテラルなset構文は、慣れれば意図は明解なので良いという主張。コンストラクターを使う呼び出し方法と、リテラルの処理で、BUILD\_SETバイトコードの実行の話になる。p87

バイトコードのdisアセンブラを見せながらの解説をしてくれる。

Frozensetには、リテラル表記はない。のでコンストラクタを呼び出すしかないとのこと。

#### 3.8.2 セット内包表記

をを、確かにセットも内包表記があってしかるべきだよな。p88

#### 3.8,3 セットの演算

ここで出てくる、「インプレイスで変更/更新」ってあんまり聞かない表現なんだけど。p88

ここで出てくるsetの操作をうまく使うとコードを短くできそう。

### 3.9 dictとsetの内部構造

内部構造の話だから、読み飛ばそうかなって思ったんだけど、性能やトレードオフの問題が書いてあるので、読み飛ばせなかった。ある程度経験を積んだプログラマなら気になることが書いてある。

この節では、
- Pythonのdictとsetはどれだけ効率的なのか。
- なぜ順序付きではないのか。
- 任意のPythonオブジェクトをdictのキーまたは、setの要素に使えないのはなぜなのか。
- dictのキーやsetの要素の順序が、挿入順に依存し、その構造が利用している間に変化することもあるのはどうしてなのか
- dictやsetに対してイテレーションを行っているとき、それらに要素を追加してはいけないのはなぜなのか

を、説明してくれる。とのこと。内部構造を知ることで、その得失点と(pythonの)低レイヤを意識することで、性能と仕様を満たすバランスを考えることになるんだろうな。という感じか。メモを書きながら読んでいるので、後で訂正するかも。

#### 3.9.1 性能評価実験

じぶんのpython3の環境で、追試してみるのも良いが、いまではない。

#### 3.9.2 ディクショナリのハッシュテーブル

#### 3.9.3 dictの構造に起因する実用上の影響

ここは一読しただけでは、よく分からない。将来のためにメモだけ残しておく。

- p97 「ユーザ定義型のハッシュ値は、id()であり、それらを比較した結果はいつも等しくないため、元からハッシュ可能です。」って、「キーはハッシュ可能なオブジェクトでならなくてはいけない」とぱっと見に反しているので、補足が欲しい気がする。
    - 等しいということは、「ハッシュが同じ」である。\_\_eq\_\_() を実装する時に注意が必要っぽい。
- dictには顕著なメモリーオーバーヘッドがある。
    - ここは重要で、どうしたら良いのかの提案もある。ただし書いてあるように、早すぎた最適化は保守性を下げるので、手早く富豪的アプローチで作ってから最適化を考えるというのも動かさないと評価できないので、一つの知見でもあろう。
- キーサーチは非常に高速ってのは、スペースと時間がトレードオフになっている。アクセス時間はサイズに関係ない。サイズを指数的に大きくしても、影響はすくない。
    - ちゅうことは、この辺が実用的なpythonのプログラムを作るに当たっての勘どころなのか?
- dictに要素を追加するとキーの既存の順序が変更される可能性がある
    - これ知っておかないとハマるだろう。既存と更新用に分けたら良いだけ。富豪的アプローチだけど副作用を考えたらね。こんな感じで困るぐらいカツカツの環境なら、言語とか仕様とか考え直して実装したほうがいいんじゃないだろうか。まずはpythonでつくって仮説を検証するでかなりの所までいけるでしょう。

#### 3.9.4 セットの挙動

これまで記述してある内容の重複をさけるためにあっさりとしているが、これもsetを使う上では勘案することである。p99-p100

### 3.10 本章のまとめ

ここも、一度通読してから、読み直して頭に定着させるためにいい感じ。

### 3.11 参考文献

あとでリンク貼る。

ここのSoapbox p101-p102 は、いまいち理解できず。ハッシュの機構がシンプルだというのは、同意できるが、正確だというのは、何に対してどう正確なのか、理解できてない。他の言語の記述方法に似ていることと正確さに何の関連があるのか。正確というのは何かの基準があってそこへの差分が一定範囲内だという理解なので、いまいちピンときていないのだと思う。

## 4章 テキストとバイト

ここは、どのぐらいの事前知識を必要とするのだろうか。Unicodeのの時代だし、CJKに深く突っ込む所でもないから、文字コード本みたいな副読本はいらないかもしれない。とか思ったが、そんなことなさそう。Unidodeのバージョンの話がでてくるから、制定の話と改訂の話ぐらいは知っておくのは、この本を読む前に知っとけということ。

文字とバイトを区別するという話なので、まずは読み進めてみる。下記のトピックについて解説するとある。

- 文字、コードポイント、およびバイト表現
- bytes, bytearrary,memoryviewといったバイナリーシーケンス固有の機能
- Unicodeおよび従来型の文字セットの完全なコーデック
- エンコーディングエラーの回避と処置
- テキストファイル処理におけるベストプラクティス
- デフォルトエンコーディングと標準入出力の問題
- 正規化による安全なUnicodeテキストの比較
- 正規化、ケースフォールディング、付加記号を強引に除去するユーティリティ関数
- localeとPyUCAライブラリを用いたUnicodeテキストの的確なソート
- 文字とメタデータを収録したUnicodeデータベース
- strとbytesを処理するデュアルモードAPI

はい。もうこの段階で、Codecが具体的に何を指しているのか、とか、Unicodeの正規化について具体的なイメージが沸かないので中身を読み進めたくなってきました。
ケースフォールディングに関しては、監訳者の注があるので意味が分かりました。MySQLとかでも問題になっていた件をpythonでどう解決するではないかと思いましたが、当たっているかどうかは読み進めてみないと分かりません。最初印象ってか予期しているバイアスを書いておいて後から自分で修正するスタイルで。

### 4.1 文字の問題

Unicodeをpythonで扱ってみて、皆さん慣れてくださいね。のパートです。

もうpython3に移行していると思うので、python2の記述は過去の資産をメンテする必要がなければ、読み飛ばしていきます。

### 4.2 バイトについて

C言語をやったことがあれば、unsigned charとか、unsigned char \* で操作してる感じよね。って感じの話っぽい。低レベルな技術者[^低レベルな技術者]なら、するすると読み下せそう。

[^低レベルな技術者]: 誤解させる言い方ですね。正確には、低レベルのレイヤを対象する技術者、アセンブラ/C言語でのシステムプログラミング以下、組み込み系とか、OSとかを触る感じの人です。

ここで出てくる、encodeとdecodeの例えは、図があったほうがいいな。本に落書きするか。

#### 4.2.1 structとメモリビュー

これ、まんまC言語のstructで型にハメるやりかたや。memoryviewでunionってか参照させる感じなんや。こんな低レイヤなことできるんだな。

### 4.3 基本的なエンコーダとデコーダ

エンコーダとデコーダの両方を指す言葉として、コーデックと呼んでいるのがここに来てわかった。

参考になるが、CJKの本ではないので、日本語を扱うのであれば、Linux上でつかっているし、utf-8一択だな。発展的に調べるとCP932とかも多分あるんだろうけど。

サロゲートペアの説明をp111でしているのは良い。

### 4.4 エンコードとデコードの問題点

以下で個別に、エラーへの対処策が書いてあるので、困ったときにはそこを読めば良いってのは、困っている人向けに書いているからだろうな。

#### 4.4.1 UnicodeEncodeErrorへの対処策

P112-p112

#### 4.4.2 UnicodeDecodeerrorへの対処策

p113-p114

#### 4.4.3 予期しないエンコーディングでモジュールをロードしたときのSyntaxError

p114-p115

コラムの「ソースコードでASCII文字でない名前を使ってよいものでしょうか」はおもしろい
が使っていいときと使ってよくない時があるし、思っている以上に使われる可能性があるなら
やめとけなんだろうね。

#### 4.4.4 バイトシーケンスのエンコーディングを知る方法

そりゃそうだろうな。知っている所から(生成側)から教えないと正確な所は分かるまい。できても推測までで、身近な例だとブラウザがやっている。長い文字列なら判別できるが、短いと文字化けした経験はあるだろう。

#### 4.4.5 便利だけど厄介なBOM

UTF16エンコードのBOMの話です。GNU/LinuxならUTF8で幸せなんだけど。P117-P118

### 4.5 テキストファイルの処理

GNU/Linux環境なら、デフォルトがUTF8なのでこれに悩むことはないが、他のエンコードをもつシステムとデータのやりとりをする必要があるなら読んでおこう。ネット上にも記事はあるが、せっかく買ってあるのだから読めば良い。P118-P121

#### 4.5.1 大混乱なデフォルトエンコーディング

使っているOSで、どういう風にデフォルトエンコーディングになっているかの説明をしている。確認方法を提供しているので、混乱したらここから調査を開始するのもいいかと。P121-P124

### 4.6 適切な比較のためのUnicodeの正規化

ソートを含めて文字の大小比較をどうするかについて。アクセント記号の話題だったりするが、日本語でもまったく関係ないわけでもない。うに濁点とか。絵文字とか。は本書で取り上げていないけど関係ある。あと検索時にアクセント記号をつけていなくても付けているの同じように検索したいとかありそうな仕様ですし。日本語だとカタカナだろうがひらかなだろうが、同一視したいとか。と考えたらいいのかな。

本文例だと、1/2を3文字のASCIIで入力してもUnicodeの一文字1/2を同一視することを書いている。

監訳者注で、NFC,NFD,NFKC,NFKDについて略していない用語をだしている。これらの意味を知りたいならUnicode本が必要っぽい。この辺書いた本があれば後でここに書き足そう。文字コードの本は何冊かあるはず。オンラインで検索してもいいけども

P124-P127

#### 4.6.1 ケースフォールディング

基本的には、すべての文字列を小文字に変換することなのか。例外もある。が本文を参照してほしい。p127

#### 4.6.2 テキストを正規化してから比較するユーティリティ関数

NFCとNFDが出てくるが、p125 で用語の説明がしてある。

#### 4.6.3 付加記号う取り除く極端な正規表現

著者としては、力のはいっている部分なんだろうと思う。でも日本語話者としては、もっと身近な例がいいな。

p128-o133

### 4.7 Unicodeテキストのソート

localeに応じてソート。GNU/Linuxなら充分に動くが、...

#### 4.7.1 Unicode照合アルゴリズムでソート

ここで、PyUCAが出てくる。localeは見ずに、結果をカスタマイズすることができる。GNU/Linux以外の人には朗報だね。p135

### 4.8 Unicodeデータベース

- [Unicode HOWTO — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/howto/unicode.html)
    - これも副読文書としてリンクしておこう。
- [unicodedata --- Unicode データベース — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/library/unicodedata.html)

正規表現については、いまでもPyPIの方が優れているのだろうか。新しいバージョンで更新されているのかとか確認する方法は、簡単に分かったりしないのだろうか。開発を追っかけるのが堅い手ではあるのだけども。

### 4.9 str/bytes デュアルモードAPI

#### 4.9.1 正規表現におけるstrとbytes

具体例がでてくる。

CJKのってか、日本語の場合は??

#### 4.9.2 OSモジュールにおけるstrとbytes

GNU/Linux上での説明に始まり、他のプラットホームはそこそこ。

この扱いをみていると、一番便利なのはGNU/Linux上でUTF8で使うことで、私はそのど真ん中の例なんだな。

### 4.10 本書のまとめ

これ理解するのは、本当に大変で、資料を読んで、自分の卑近て例だけでわかった気になるとヤバいやつだというのはわかった。GNU/Linux上で、Pythonを使っている幸せを感じてポーティングするより windowsとかでもwsl2もあることだし、そっちで何とかしてくれと言うのが良さそう。もうUTF8で幸せになろうよ。ってのが私の感想です。

## 5章 第一級関数

最初に、Guidoが、関数型言語から影響を受けたとは思っていないという引用から始まる。しかしこれを明言しない理由は何だったんだろうか。

2020-07-12 06:47

第一級関数=第一級オブジェクトの定義を読んでいて、気になることがある。

- ランタイムに生成できる。
- データ構造の中の変数や要素に代入できる
- 関数の引数として渡すことができる
- 関数の結果として返すことができる

で、最初のランタイム[^ランタイム]に生成できる。というのに違和感がある。ランタイムは、実行バイナリのことを指してランタイムということがある。が、pythonの場合コンバイラとしてバイナリを吐き出すのが、いつでも成り立つ訳ではない。実行している時にとか、プログラムを実行している間にとか、そういう意味ではないのか。

[^ランタイム]: REPLのことをコンソールセッションと呼び、関数を「ランタイム」で生成しているので、実行可能バイナリのことを指してランタイムと呼んでいるわけではなさそうです。

関数が第一オブジェクトでない言語って、BASICとかかな。最近の言語だと可能なのが多いので分からんようになるわ。

### 5.1 関数をオブジェクトのように扱う

実例をだしている。

### 5.2 高階関数

ここでの高階関数の定義は、「関数を引数として受け取ったり、結果として関数を返したりする関数」とのこと。この定義は、ボケットリファレンスのp268にある 「16-1-3 高階関数を使う」においても同じ内容であった。

#### 5.2.1 map,filter,reduceの最新の代替

もう、python2は考慮しなくてよいものとして読むスピードを上げる。

map,filter,reduceよりも、リスト内包表記やジェネレータ式で代替できるので、使われなくなった。というのは、なるほどと思った。パイソン風(pythonic)なプログラミングでは、そう書くのだと。例5-5でmapをリスト内包表記に書き換えている実例を出している。

例 5-6 で、reduceを使う典型例として、合計値を求めるのに、sumを使う例を出している。

mapとfiltgerは、ジェネレータを返すので、その扱いを変えるのが良いという話である。これも使う関数を真似るのではなく、使っている真意をマネよってことで。読んでよかったなと。

一つの値というか結果に「集約」するというのが、キモだということ。

あとの10.5や、14.11 でのイテラブルについても言及すると先触れを出していている。

ちなみに、ポケットリファレンスでは該当するページはp269-p271であるが、ここの部分の学びについては書いていないので、自分で追記しておく。

### 5.3 無名関数

lambdaの話。

いつ使えが明解でよい。


頑張りすぎて、わかりににくいlambdaを除去するリファクタリングレシピもいい。p154

- [関数型プログラミング HOWTO — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/howto/functional.html)
    - これは、Fluent Pythonが勧めているリンクである。そして、このhowtoが公式に取り込まれているのも、最初のGuido氏の言葉の引用はいったい。著者の冗談と取るべきなのか。それとも?

### 5.4 7つの呼び出し可能オブジェクト

呼び出しオブジェクトについて、列挙し、コメントをして理解しやすくしてくれている。後のために、ジェネレータ関数の所で、コルーチンについて言及している。また呼び出し可能か判定するのは、そのオブジェクトのcallable()を呼んでみる。のを実例を入れて書いている。p154-p156

### 5.5 呼び出し可能なユーザ定義型

[example-code/bingocall.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/05-1class-func/bingocall.py)
    - インスタンス化する時にクラスを実行する
    - インスタンス化したオブジェクトを実行すると、 \_\_call\_\_(self):を定義してどんな戻り値にするか決めることができる。

疑問点
: p157で書いてある、クラスに、 \_\_call\_\_ を実装すれば、の下りは、ここで何を言っているのか意味がよく分からない。他の人とも議論してみたい。

### 5.6 関数のイントロスペクション

### 5.10 関数型プログラミングのためのパッケージ

純粋な関数型プログラミングう行うというよりも、lru\|cache などのデコレータを便利に使うための手段して関数型を取り込んでいるというのが、後から読み直した時の所感です。便利に使うためにはA事前に学んでおかないといけないので、後で効いてくる。



## 6章 第1級関数を使ったデザインバターン

see also オライリーの実践python3の方が、デザインパターンについて詳しいのであるが、本書では、Strategry のパターンについて繰り返しpythonの異なる機能を用いて紹介している。

### 6.1 リファクタリングのケーススタディとしての Strategy パターン

#### 6.1.1 典型的な Strategy パターン

抽象基底クラス(ABC) として使うために、@abstractmethodデコレータを使っている。7章を読んだ後だと、やはりpythonは、デコレータの使いこなさないといけない。

#### 6.1.2 関数指向の Strategy パターン

#### 6.1.3 シンプルな方法による最良の Strategy の選択

気をつける点について、解決方法を下記で解決策を提示している。

#### 6.1.4 モジュールにある Strategy を検索

* globals()を使って関数を見つける
* イントロスペクションを使う

詳細は、本書のp186-p187を参照せよ。

### Command パターン

図6-2 p188のUML図

実行するコマンドのリストを生成する、より高度なundoを実装するためのヒントを提案してくれている。 \_\_call\_\_ メソッドをわかってからここにくる必要がある。

### 6.3 本章のまとめ

Design Pattern は、金科玉条でなく、言語の特性を応じて、コードの書き方でなくアイデアを活かして実装する話である。なので、他言語で慣れていても、pythonらしい書き方をする。(Fluent python)にあてはめ、こういう風にするのだ。ということを著者は言いたかったのだろうな。と思いながら読んだ。

### 6.4 参考文献

Soapboxで、7章に、Visitorパターンを作るときに、有用であるという、ジェネリック関数を予告している。また、CLOSのマルチメソッド[^CLOSのマルチメソッド]など予告しており、脳内の関連情報を読者に伝えたい意図を感じた。

[^CLOSのマルチメソッド]: LISPの話? [clojure - common lisp wikipedia - 解決方法](https://code.i-harness.com/ja-jp/q/91c501) や一般的には、[多重ディスパッチ - Wikipedia](https://ja.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E3%83%87%E3%82%A3%E3%82%B9%E3%83%91%E3%83%83%E3%83%81) とも呼ぶようだ。

## 7章 関数デコレータとクロージャ

デコレータを使いこなすためには、クロージャの理解が必要とのこと。

p194にある。

- Pythonのデコレータ構文の評価方法
- 変数がローカルであるかを Python が判断する方法
- クロージャの存在意義とその挙動
  nonlocalで解決できる問題

上記の説明をこの章で受けて、クロージャの挙動がよくわかったので、とても良かった。python ポケットリファレンスでは、端的に説明されていて、理解できていなかった。これは、ボケットリファレンスなので、この様な概念をキチンと説明するのは荷が重いのは理解するが、重要な概念だけに省くことはできなかったのだろうな。とも思う。プログラミング経験者が、pythonの教科書を購入するなら、ここは一つ内容を確認しておくのがいいのではないか。と私は思う。もちろん、もう理解しているから要らないと意見もあるかもしれない。

### 7.1 デコレータの基礎

どういう動作をするか。についてのチュートリアル。

### 7.2 デコレータ実行のタイミング

ここのキモは、デコレータの実行タイミングを書いており、インポート時に何が起きているのか。を書いている所です。たしかに、そういう風に動くにはこのタイミングか。というのは理解できる。

### 7.3 デコレータを使った Strategy パターンの改善

例7-3は、[example-code/strategy_best4.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/strategy_best4.py) が該当する

動いているコードで、理解を深めるのがいい。

### 7.4 変数スコープ

ここで、pythonでのスコープを確認する。

例7-4, 例7-5 は、[example-code/global_x_local.rst at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/global_x_local.rst)　が該当するようだ。

ローカル変数を、globalとして扱うための説明で、nonlocalの説明の前フリである。

### 7.5 クロージャ

クロージャは、理解されにくいのか。違うモノと混同されている。

- 例 7-8
    - [example-code/average_oo.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/average_oo.py)
- 例 7-9
    - [example-code/average.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/average.py)


図 7-1 ここの自由変数の図を読もう。

これ、例7-11 例7-12など

### 7.6 nonlocal宣言

例 7-13 例 7-14 も既存か。

ここの説明が、python3になって、nonlocalが導入された説明になる。python2においてのやり方が書いている。p206

### 7.7 シンプルなデコレータの実装

#### 7.7.1 コードの解説

\_\_name\_\_ と \_\_doc\_\_ を覆い隠さないバージョン で、なんでこうなるかについても説明している。

functoolsのなかにある functools.wraps は、[functools --- 高階関数と呼び出し可能オブジェクトの操作 — Python 3.8.5 ドキュメント](https://docs.python.org/ja/3/library/functools.html?highlight=functools%20wraps#functools.wraps) であり、functools.update\_wraps [functools --- 高階関数と呼び出し可能オブジェクトの操作 — Python 3.8.5 ドキュメント](https://docs.python.org/ja/3/library/functools.html?highlight=functools%20wraps#functools.update_wrapper) を呼んでいるので、こっちも見る必要がある。

### 7.8 標準ライブラリのデコレータ

property, classmethod, staticmethodの説明は後にするとのこと。functools.wraps は、既に紹介した。lru\_cacheとsingledispatchの説明をするとのこと。

#### 7.8.1 functools.lru\_cache を用いたメモ化

メモ化
: ここのnoteの主旨からは外れるかも知れないが、lru\_cache を「メモ化」という表現は、pythonにおける定訳だと気がつくまで、かなり違和感があった。
lru\_cacheの概念を「メモ化」という概念で日本語として互換だと消化するまでに時間がかかったからです。記録してすぐに参照するというコアなアイディアを共有すると良かったのだと今にしては思う。納得しがたかったのは、自分が、lru\_cacheの動作の方から考えていたからなのだろう。

ここでのコア・アイディアは、一回実行した結果をlru方式で記録しておく。その時の条件として、入力が一定なら、必ず同じ出力をするのであれば再利用が可能だから。というもの。なので引数と出力をメモっておく。ただ気をつけないといけないのは、プログラム内部で、乱数や時刻などを参照していると同じ結果にならないので、何でもかんでもメモ化していいという話にはならない。

また、キャッシュをシステムで多重に持つと副作用があるので、どのレイヤで何のキャッシュを持っているのか。を設計時に決めておかないといけない気がする。そのためには、最初からパフォーマンス計測を計画して、プログラムに組み込んでおく用心深さがいるのかもしれない。

当てずっぽでなく、データを収集する。は、話がfluent pythonから脱線したが、デコレータで気軽につかえるlru\_cacheは、プログラミングテクニックとして、覚えておくのは良い。ちょっとずつ違うことを繰り返し参照する場面では強力な手助けになるだろう。

- [example-code/fibo_demo.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/fibo_demo.py)
- [example-code/fibo_demo_lru.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/fibo_demo_lru.py)

#### 7.8.2 シングルディスパッチのジェネリック関数

- [example-code/generic.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/generic.py)

パッと見には、JavaやC++のオーバーロードと同等に感じるかも知れないが、p215で書かれている内容を、いまは理解できていない。得失点まで含めて人に説明できるようにならないと理解したとは言えないだろうし。

ここでの、抽象基底クラス(ABC)推しも、体感してみるのと、その便利さは何が代償なのかを確認しないとよくわからない。コードの拡張性とのトレードオフは、実行速度だったりすることもある。でも、pythonで書いている時点で、ある程度割り切りはできているはずで、その基準内であれば拡張性を優先するのはありえる話です。

### 7.9 多重デコレータ

デコレータを複数回実行すると何が起きているのかを記述している。p214

pythonポケットリファレンスのp273 16-1-7 デコレータ構文を利用する

の記述では、よくわからない挙動の確認に。ここと次の部分は有用だと感じた。

「実践Python3」の 2.4.2 クラスデコレータ p59 に、多重デコレータの適用順がある。クラスが生成されてから、下から上に向かって順に適用されていく。との記述あり。クラスデコレータと、関数デコレータの評価順を一応確認しておくこと。2020/07/31

### 7.10 パラメータ化デコレータ

- [example-code/registration.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/registration.py)

p216 の本節の最初の行を、なぜにpythonポケットリファレンスは、書いていないのか。経験を積むとわかるのだろうか。でも紙面が少ないから削られたのか。わからないけどもここは、自分で書き込みをして補っておく場面だよな。

いや、本に書き込むスペースぐらいでは足りないので、書き付けた紙を挟んでおくと、まだまだ書けるぞ。

#### 7.10.1 登録デコレータのパラメータ化

p217 ここで、デコレータファクトリの説明をしている。

#### 7.10.2 clockデコレータのパラメータ化

### 7.11 本章のまとめ

メタプログラミングの入り口かぁ。

### 7.12 参考文献

Soapbox の「自由変数」に関する記述が気になった。

あと、pythonのデコレータと、デザインパターンのDecorator

## 8章 オブジェクト参照、可変性、リサイクル

8章のテーマは、オブジェクトと、オブジェクトにつけられた「名前」の区別をする。という話とのこと。

一時期よく見かけた、変数は箱のメタファーは間違っている。という話をpythonからの視点で説明する。

- オブジェクトの同一性(identity)
- 値(value)
- エイリアス(alias)

の概念を説明し、shallow copyとdeep copy を説明する。

### 8.1 変数 != 箱

確保されたメモリ領域へのラベルという解釈をした。

### 8.2 同一性、等価性、エイリアス

例 8-3 は、とくに簡単なのでサンプルプログラムはない模様。同じオブジェクトを別の名前が、指している例

aliasと、同じ値のオブジェクトを持っているだけでは、意味が違う。この意味は、誤解しているとバグう生みそう。

p233の、Python言語リファレンスの引用、 [3. データモデル — Python 3.8.5 ドキュメント](https://docs.python.org/ja/3/reference/datamodel.html#objects-values-and-types)
は、fluent pythonの訳と、有志で日本語にしている訳では、表現は異なっていますが、大意は同じものだと思うので、左記にlinkをはっておきました。

内容が同じでも、オブジェクトのID[^オブジェクトのID] は異なる。実装依存であっても、形式と意味する内容が決められているという部分が大事で、オブジェクトが存在している間は不変だということがキモっぽい。

[^オブジェクトのID]: 識別子というか、このIDって実装依存なんや。

#### 8.2.1 == と is の使い分け

この部分、pythonポケットリファレンスだと、さすがに記述はあってもどういう風に使うのかを理解できるようになるのを期待したい。

典型例として、

```python
x is None
x is not None
```

があるので、Noneかどうかを高速に比較したい。という、検査目的を感じた。

ダンダーとして、 \_\_eq\_\_ の話に及んでいるので、2つのオブジェクトが、中身を検査するのが、コストが高いというのは理解できたと思う。shallow copyやdeep copyへのネタ振りでもあろう。

#### 8.2.2 タプルの相対的な不変性

ここのタプルが不変だという話を理解しておかないと、参照先では変化しうるけど、タプルなんで、そんなことない。って思い込みそうなので、読んでおきましょう。

### 8.3 デフォルトのコピーは「浅い」

ここの実験も、見ているだけだと、そうやな。って思うだけ。で、期待しない動きになってから、ここを読み返すことになる。

#### 8.3.1 任意のオブジェクトの「深い」コピーと「浅い」コピー

deep copy と shallow copyの話。

例 8-8 生徒を乗せたり降ろしたりするバス

のコード例は、

  [example-code/bus.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/08-obj-ref/bus.py)

上記のコードを使って

- copy
- deepcopy

の実例


### 8.4 参照としての関数の引数

pythonは、共有渡し(call by sharing)だけということだが、c言語をやってきた自分には、call by valueとcall by referenceという言い方が馴染んでいる。


#### 8.4.1 引数のデフォルト値に可変型を使うのは考えもの

- [example-code/haunted_bus.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/08-obj-ref/haunted_bus.py)

問題があることを、例 8-12 可変なデフォルト値の危険性を説明する簡単なクラス で説明している。生徒の幽霊がでるお化けバス haunted bugってことみたい。

<http://pythontutor.com/live.html#code=%22%22%22%0A%3E%3E%3E%20bus1%20%3D%20HauntedBus%28%5B'Alice',%20'Bill'%5D%29%0A%3E%3E%3E%20bus1.passengers%0A%5B'Alice',%20'Bill'%5D%0A%3E%3E%3E%20bus1.pick%28'Charlie'%29%0A%3E%3E%3E%20bus1.drop%28'Alice'%29%0A%3E%3E%3E%20bus1.passengers%0A%5B'Bill',%20'Charlie'%5D%0A%3E%3E%3E%20bus2%20%3D%20HauntedBus%28%29%0A%3E%3E%3E%20bus2.pick%28'Carrie'%29%0A%3E%3E%3E%20bus2.passengers%0A%5B'Carrie'%5D%0A%3E%3E%3E%20bus3%20%3D%20HauntedBus%28%29%0A%3E%3E%3E%20bus3.passengers%0A%5B'Carrie'%5D%0A%3E%3E%3E%20bus3.pick%28'Dave'%29%0A%3E%3E%3E%20bus2.passengers%0A%5B'Carrie',%20'Dave'%5D%0A%3E%3E%3E%20bus2.passengers%20is%20bus3.passengers%0ATrue%0A%3E%3E%3E%20bus1.passengers%0A%5B'Bill',%20'Charlie'%5D%0A%0A%0A%3E%3E%3E%20dir%28HauntedBus.__init__%29%20%20%23%20doctest%3A%20%2BELLIPSIS%0A%5B'__annotations__',%20'__call__',%20...,%20'__defaults__',%20...%5D%0A%3E%3E%3E%20HauntedBus.__init__.__defaults__%0A%28%5B'Carrie',%20'Dave'%5D,%29%0A%3E%3E%3E%20HauntedBus.__init__.__defaults__%5B0%5D%20is%20bus2.passengers%0ATrue%0A%0A%22%22%22%0A%0A%23%20BEGIN%20HAUNTED_BUS_CLASS%0Aclass%20HauntedBus%3A%0A%20%20%20%20%22%22%22A%20bus%20model%20haunted%20by%20ghost%20passengers%22%22%22%0A%0A%20%20%20%20def%20__init__%28self,%20passengers%3D%5B%5D%29%3A%20%20%23%20%3C1%3E%0A%20%20%20%20%20%20%20%20self.passengers%20%3D%20passengers%20%20%23%20%3C2%3E%0A%0A%20%20%20%20def%20pick%28self,%20name%29%3A%0A%20%20%20%20%20%20%20%20self.passengers.append%28name%29%20%20%23%20%3C3%3E%0A%0A%20%20%20%20def%20drop%28self,%20name%29%3A%0A%20%20%20%20%20%20%20%20self.passengers.remove%28name%29%0A%23%20END%20HAUNTED_BUS_CLASS%0Abus1%20%3D%20HauntedBus%28%5B'Alice',%20'Bill'%5D%29%0Abus1.pick%28'Charlie'%29%0Abus1.drop%28'Alice'%29%0Abus2%20%3D%20HauntedBus%28%29%0Abus2.pick%28'Carrie'%29%0Abus3%20%3D%20HauntedBus%28%29%0Abus3.pick%28'Alice'%29%0Abus2.pick%28'Bill'%29%0Abus2.drop%28'Carrie'%29%0Abus3.pick%28'Carrie'%29%0A&cumulative=false&curInstr=42&heapPrimitives=nevernest&mode=display&origin=opt-live.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false>

で、実行してみて解ったことがある。

#### 8.4.2 可変な引数を使うプログラムを頑強に

例 8-15 引数変更の危険性を示す簡単なクラスとして下記の例がでている。
- [example-code/twilight_bus.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/08-obj-ref/twilight_bus.py)

passengerのチェックをすることで、独立というか、別物にできる。ここは、また訪れて確認しないとわかった気にならないな。

<http://pythontutor.com/live.html#code=%22%22%22%0A%3E%3E%3E%20basketball_team%20%3D%20%5B'Sue',%20'Tina',%20'Maya',%20'Diana',%20'Pat'%5D%0A%3E%3E%3E%20bus%20%3D%20TwilightBus%28basketball_team%29%0A%3E%3E%3E%20bus.drop%28'Tina'%29%0A%3E%3E%3E%20bus.drop%28'Pat'%29%0A%3E%3E%3E%20basketball_team%0A%5B'Sue',%20'Maya',%20'Diana'%5D%0A%22%22%22%0A%0A%23%20BEGIN%20TWILIGHT_BUS_CLASS%0Aclass%20TwilightBus%3A%0A%20%20%20%20%22%22%22A%20bus%20model%20that%20makes%20passengers%20vanish%22%22%22%0A%0A%20%20%20%20def%20__init__%28self,%20passengers%3DNone%29%3A%0A%20%20%20%20%20%20%20%20if%20passengers%20is%20None%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20self.passengers%20%3D%20%5B%5D%20%20%23%20%3C1%3E%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20self.passengers%20%3D%20passengers%20%20%23%3C2%3E%0A%0A%20%20%20%20def%20pick%28self,%20name%29%3A%0A%20%20%20%20%20%20%20%20self.passengers.append%28name%29%0A%0A%20%20%20%20def%20drop%28self,%20name%29%3A%0A%20%20%20%20%20%20%20%20self.passengers.remove%28name%29%20%20%23%20%3C3%3E%0A%23%20END%20TWILIGHT_BUS_CLASS%0Abasketball_team%20%3D%20%5B'Sue',%20'Tina',%20'Maya',%20'Diana',%20'Pat'%5D%0Abus%20%3D%20TwilightBus%28basketball_team%29%0Abus1%20%3D%20TwilightBus%28basketball_team%29%0Abus2%20%3D%20TwilightBus%28basketball_team%29%0Abus1.drop%28%22Tina%22%29%0Abus2.drop%28%22Pat%22%29&cumulative=false&curInstr=26&heapPrimitives=nevernest&mode=display&origin=opt-live.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false>

確保したオブジェクトを使いまわすのは、C言語の、call by referenceと同じように思ってしまうが、本章のSoapboxの部分もあるので、また読み直して理解に努めたい。

なお、前節 「8.4.1 可変な引数を使うプログラムを頑強に」と異なるのは、可変な引数の内容が、[]な時と、そうでない時に、同じオブジェクトを指していないことが確認できる。前者と、初期値を[]かどうかで振り分けている本節のプログラムの差については、理解した気がするが。 see also 本章のSoapbox

### 8.5 delとガベージコレクション

delは、名前を削除し、ガベージコレクションは、オブジェクトを削除する。CPythonのガベージコレクションは、reference counterを使っているとのこと。ガベージコレクションはそれだけで、一つの学ぶべき分野であるが、fluent python p245 ではreference cunterの説明がなされている。

weakref.finalize ってので、オブジェクトが削除されたときに実行されるコールバックを設定できることを知る。

名前を削除すると、到達性がなくなり、ガベージコレクションを動くという連鎖が理解できたらいいのかな。

CPython 2.0 は、世代別ガベージコレクターとあるが、脚注に、監訳者からの説明あり。 p245

### 8.6 弱参照

オブジェクトで、置いておく必要がないもの。本書では、cacheが例に上がってきている。を積極的にメモリーへ返却したい時にどうするか。という話と、こんなん事前に調べとかないとわかる訳ないやん。的なtipsもあって、p247 の部分はまた再訪します。

#### 8.6.1 コント「Weak Value Dictionary」

- [example-code/cheese.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/08-obj-ref/cheese.py)

解説を読んでも、疑問だったので、globalの定義を読み直さないと間違えそう。他の言語のフワッとした感覚だといかんな。pythonポケットリファレンス p183にて確認する。

私の理解によるスコープは、2つの条件で決定される。

1. 使用する場所(宣言する、確保すると考えてもいい) #A
1. 代入する場所 #B

 #Aが関数外で宣言というか確保されていると、グローバル変数となり、関数宣言をしてから、グローバルと同じ関数名を使って代入をすると、別途ローカル変数として扱われる。グローバル変数にアクセスしたいなら、global宣言が必要。というか別の名前にするという手で問題にならないのか。古き変数名に属性を持たせるという方式だったら困らないってことか。

また、グローバル変数は行儀がよくないから、クラスの中に閉じ込めるクラス変数などに閉じ込めるので、ここを意識してこなっかった。

クロージャの場合は、関数宣言をして、そのまた中から、外の関数で定義された自由変数にアクセスする。ただ変数を見たいというだけなら、再代入を伴わないことはマレなので、やっばりnonlocal宣言は必要か。

 #B の再代入というのがキモな気がする。その時にどの変数にアクセスしたいのかを明確に意識しそう。


あと、WeakSetの説明は、リファレンスで書いていない、注意すべきことを書いているので読んでおけ。p250

#### 8.6.2 弱参照の制約

dictやListについての制約があること、そしてその制約を外す方法 p250

### 8.7 Pythonが不変型で使っている魔術

この節は、飛ばしていいとのことで、何周かして余裕があったら読む。

### 8.8 本章のまとめ

ここの部分を読んで、内容の確認をする。

### 8.9 参考文献


### Soapbox

また、Soapboxの「共有渡しによる引数の受け渡し」を読んで、単純に、call by reference という言い方ではいかんというのがやはり理解できていない。p256

> Pythonの関数は引数のコピーを取得しますが、引数は常に参照です。
> そのため、参照されているオブジェクトの値は可変であれば変更されることもありますが、そのIDは変更できません。
> また、関数は引数で指定されている参照のコピーを取得するので、再バインドしても関数の外側には影響を与えません。

については、


> Pythonの関数は引数のコピーを取得しますが、引数は常に参照です。

多分理解できたとオ思う。

> そのため、参照されているオブジェクトの値は可変であれば変更されることもありますが、そのIDは変更できません。

前段は、そうだと思うが、内容が変わったら、IDが変化するんじゃないのか。IDが変更できないということは、内容を最終的に変わらないということを意味しているのか。

> また、関数は引数で指定されている参照のコピーを取得するので、再バインドしても関数の外側には影響を与えません。

参照のコピーといっても、shallow copyなので、同じオブジェクトを参照しているのではないのか。そして「再バインド」という言葉が出てくるが、何となくの意味でなく、pythonにおける変数の再バインドとは、何か。再代入のことなのか?

という疑問があるので、やっばり理解しているとは思えない。また、わかったら追記する。

2020/08/01
: idは変わらない。というのは、下記のようだ。

```python
>>> a = ["aaa","bbb","ccc"]
>>> def fna(arga):
...     b = arga
...     b.append("ddd")
...     print(b)
... 
>>> def fnb(argb):
...     c = argb
...     c.append("eee")
...     print(c)
... 
>>> print(a)
['aaa', 'bbb', 'ccc']
>>> fna(a)
['aaa', 'bbb', 'ccc', 'ddd']
>>> fnb(a)
['aaa', 'bbb', 'ccc', 'ddd', 'eee']
>>> print(a)
['aaa', 'bbb', 'ccc', 'ddd', 'eee']
>>> id(a)
140204036553472
>>> fna(a)
['aaa', 'bbb', 'ccc', 'ddd', 'eee', 'ddd']
>>> id(a)
140204036553472
>>> fnb(a)
['aaa', 'bbb', 'ccc', 'ddd', 'eee', 'ddd', 'eee']
>>> id(a)
140204036553472
>>> print(a)
['aaa', 'bbb', 'ccc', 'ddd', 'eee', 'ddd', 'eee']
```

オブジェクトのIDは不変でも、内容は変わっていくってことは、こういうことか。

## 9章 Pythonic なオブジェクト

ここでは、ユーザ定義型を作るテクニックについて学ぶようだ。p259

この章で学ぶのは、

* repr()やbytes()など、オブジェクトを異なる表現で示す各種の組み込み関数を使えるようにする方法
* 別バージョンのコンストラクタをクラスメソッドとして実装する方法
* 組み込みメソッドのformat()や、str.format()メソッドが用いる書式指定ミニ言語の拡張方法
* 読み取り専用属性へのアクセス
* セットやdictのキーとして、利用するためのハッシュ可能オブジェクト
* \_\_slots\_\_ によるメモリの節約

と、下記の議論をするようだ。

* @classmethodおよび@staticmethodデコレータをいつ、どのように使用すべきか。
* Pythonのプライベート属性とプロテクト属性の用法、慣例そして制約

どういう関連でこれを本章に入れているのかは、最初の段階ではよくわからない。読み進めるとおいおいとわかるのだろう。

### 9.1 オブジェクトの表現

* repr() --- \_\_repr\_\_
* str() --- \_\_str\_\_

の説明をしたあとに、

* \_\_bytes\_\_
* \_\_format\_\_

をする模様だ。

ってことで、この章もダンダーメソッドについての説明であるようだ。

### 9.2 Vectorクラス再訪

例 9-2
- [example-code/vector2d_v0.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/09-pythonic-obj/vector2d_v0.py)

typecodeについては、fluent python p52 または、[array --- 効率のよい数値アレイ — Python 3.8.5 ドキュメント](https://docs.python.org/ja/3/library/array.html?highlight=%E3%82%BF%E3%82%A4%E3%83%97%E3%82%B3%E3%83%BC%E3%83%89) にある「型コード」を参照せよ。fluent pythonと、公式ドキュメントの用語が違うのは、訳者が違ったり、翻訳の用語リスト、翻訳メモリが違うのだろう。読者側で、変換して吸収するしかない。


### 9.3 別バージョンのコンストラクタ

classmethodについては、まずは気にせずに読み進めて戻るのがいいってこと。?

- [3. データモデル — Python 3.8.5 ドキュメント](https://docs.python.org/ja/3/reference/datamodel.html#types) のクラスメソッドで検索
- [組み込み関数 — Python 3.8.5 ドキュメント](https://docs.python.org/ja/3/library/functions.html?highlight=classmethod#classmethod)
    - classmethodについては、ここの説明だけで理解するのは難しい。

とか、見ても、もっと端的に説明してもらってから詳細に入ってくれないか。とか思う。

クラスに属している、メソッドをインスタンス経由でなく、「クラス名.メソッド名」という形でアクセスして実行する形になるのかとか思うが、

Effective python 「項目 24:@classmethodポリモルフィズムを使って、オブジェクトをジェネリックに構築する」p64-p68 とりわけ、p67 での、
インスタンスメソッドポリモルフィズムと、@classmthodポリモルフィズムの対比の記述が参考になるか。

classmethodデコレータの説明は、次節で説明してもらえるようだ。

### 9.4 classmethodとstaticmethod

p264
> インスタンスでなく、クラスに対する操作を行うメソッドを定義するときに用います。

のこの周辺を読むのと、変数名の慣習について言及がある。あと、クラスに対するは、クラスに属する操作とも読めるか。クラスをインスタンス化しなくもいいというのは、そういう意味にも取れるか。

staticmethodは、classmethodとの対比で出てくる。対称性として、存在しているとなると、どう使うのか。ここに書いてある方法だけなのか。例外はあるかとか思うが、そんなことは、後からでいいか。

### 9.5 出力フォーマット

p265 実際にデリゲートされるメソッドについて書いてある。デリゲートってか実際に動作する部分と書いておくのがいいか。

- 書式指定ミニ言語仕様 [string --- 一般的な文字列操作 — Python 3.8.5 ドキュメント](https://docs.python.org/ja/3/library/string.html#format-specification-mini-language)

- str-format構文の例 [string --- 一般的な文字列操作 — Python 3.8.5 ドキュメント](https://docs.python.org/ja/3/library/string.html#format-examples)
    - {:}の例もここ。

自分の作ったクラスで、書式指定ミニ言語仕様に沿った、出力をさせたいときにどうするか。を示している。

### 9.6 ハッシュ可能なVector2d

自分の作ったクラスを、Setなどに入れて使いたいなら、ハッシュ可能にする必要がある。そして、p269-274は、その方法についてプログラムを交えて説明している。

- 例9-9
    - [example-code/vector2d_v3.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/09-pythonic-obj/vector2d_v3.py)

上記で、実装されているダンダーたち、読み取り専用プロパティにする。@propertyデコレータの詳細は19章になるとのこと。19章に至ったら戻ってくるか。

そして、 \_\_hash\_\_ として、どういう値が良いのかの例を出している。必ずしも必須ではないが、事実上readonlyなプロバティにする必要があったのもここで説明される。p271

### 9.7 プライベート属性と「プロテクト」属性

プライベート属性がどうやって実装されているのかを明らかにして、Pythonプログラマは自分で自分の足を撃ち抜ける自由もある。ので、正気なプログラマに便利な方法を提供している。

### 9.8 クラス属性 \_\_slots\_\_ によるメモリ節約

- 例9-11
    - [example-code/vector2d_v3_slots.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/09-pythonic-obj/vector2d_v3_slots.py)

ここの記述を使うハメになるのなら、NumPyやPandasを検討しようというのは良い。

#### 9.8.1 \_\_slots\_\_ の問題点

p280 使うなら読んどけ。

### 9.9 クラス属性の上書き

クラス名で動作を変えたい時に役立つ。

### 9.10 本章のまとめ

### 9.11 参考文献

### Soapbox



## 仮置場

### ジェネリック

言葉としてはよく聞くが、具体的な定義なしにフワッと使っていないか?読み落としているだけかもしれないが。動的言語なので、どのクラスに入っても有効に使える関数として書くという意味であれば、下記のmixinに近接した概念になるのではないか。下のmix-inも参照せよ。

### mix-in

- [［Python入門］多重継承とmixin (1/2)：Python入門 - ＠IT](https://www.atmarkit.co.jp/ait/articles/1909/03/news021.html)
    - 多重継承すると、何が問題となるか。、別のクラスの変数は、同じ名前で、同じクラスに入れても「別の変数」である。
    - あ、ここの説明は、継承関係は派生した側(下側)から、親に向かって矢印を引く流儀や。
    - mixinっていうても、継承の使い方で、「特別なキーワード」をつけて別の呼び方をしている訳じゃない。
    - mixin側は、self経由でごにょごにょするコードを書く。ここの意味が、Effective pythonのp74にある「Pythonでは、mix-inを書くのが容易です。それは、型にかかわらず現在の状態を調べるのが簡単にできるからです。動的インスペクションのおかげで、他の多くのクラスにも適用できるジェネリックな機能をmix-inで一度に書くことができるのです。」ということで、Pythonでいうジェネリックという概念は、この意味であると仮に理解しておく。後でまた変えるかも。
    - クラス階層という言葉があり、mix-inは、どのクラス階層にも入れることができるとあるが、これって、「どこのクラスにも入れることができるように書いている」から、できるのであってなんかトートロジーな説明ではないか。とも思える。

- [［Python入門］多重継承とmixin (2/2)：Python入門 - ＠IT](https://www.atmarkit.co.jp/ait/articles/1909/03/news021_2.html)
    - なるほど、mix-inしたクラスで、テンプレートメソッドという言葉を出している。が、これって abstraction  している部分と、implementation しているのを分けているともいえるので、同じことを別の名前で呼んでいる可能性もあるのでは。さしずめオーバーライドが、インプリメンテーションってか実装、か。ルー大柴っぽくカタカナ語が多いが、多分そういうことか。
    - 自分で実装しろよ。というやり方もこれね。
    - 最後まで読むのは会員登録がいるが、ここまで書いてあれば、なんとかなるか。
    - ってか、Effective Pythonの「項目24:@classmethnodポリモルフィズムを使ってオブジェクトをジェネリックに構築する」p64-69 に収斂していくのでは、クラスで実装するパターンとして。


### effctive python

もう第二版が出ているので、初版の正誤表はなくなったのかもしれんが、索引の mix-in クラス　の　定義が、73-74は間違っていないか
多分、74-75ではないのか。
