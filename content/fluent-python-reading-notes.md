---
title: "Fluent Python 読書メモ"
date: 2020-07-10T07:27:29+09:00
author: yabuki
draft: false
Categories:
- 読書メモ
tags:
- Python
- FluentPython
keywords:
---

## はじめに

Fluent Pythonを読むにあたって、「本を読む本」のなかで問われている問いに答える形で、読書メモを作っていこうと思う。

1. 「初級読書」 --- これは、「その文は何を述べているか」を確認するのであるが、誤読していることもあるので侮れない。まま、このレベルに戻ることもあろう。
    1. 「読み方準備期」
    1. ごく簡単な読み方を覚える
    1. 文脈をたどって知らない単語の意味をつかむ。
    1. 1つの作品から得た概念を消化して次の書籍を読む。1つの主題について幾人かの著者が述べることを比較することができるようになる。(ここに至ることができないこともある)
1. 「点検読書」 ---  時間に重点を置いて、「系統だって拾い読み」をする技術を指す。今回は、緩急を付けて読んでいるので、これに該当するとおもう。
    * 「この本は何について書いたものであるか」
    * 「この本はどのように構成されているか」
    * 「どのような部分に分けられているか」
    * 「この本は、どういう種類の本か」
1. 分析読書
1. シントピカル読書」(他の本と比較しつつ読む)

と、「批判的読書のコツ 20のポイント」も押さえたい。あと、分析読書をいうか、内容を噛み砕く時の手がかり、足がかりのメモも残したい。

## 対象としている読者

page xiiにある。

python以外から、pythonを書くようになったプログラマーが、これまで培ったプログラミングのノウハウを越えて、**「pythonらしい」** プログラムを書きたい場合に参照する本であり、python3を使いこなしたい人向けであるとのこと。

一定以上pythonを理解している必要があるので、読者はオススメしてあるドキュメントやチュートリアルをやっておく必要があるかもしれない。

また、python初心者がこの本を読むと、なんでもこの本に書いてあることを実践したくなるので、止めた方がいいともある。知っていて使わないという選択ができないと有害でもある。

----

*yabuki (注)*

読み進めるにつれて、対象の読者は、pythonの一通りについて分かっていて、用語もばっちりokという感じでないと、ふんふんと読み進めることは厳しいかも。こうやって読書メモを作る習慣がないと読みきるのも辛いかも。一人じゃなくて仲間で分担したほうがいいね。

それか、分からないことを調べるのをグッと我慢して、ある程度読み進めてから目星う付けて調べるでもいいか。うまく緩急を付けるのがコツか。

### 知っていた方がいいこと

* REPL --- 対話型コンソールについては、ちょっとしたプログラムを動かすのに便利だ。
* doctest

あと、紙の本に落とす時にリンクは別にしてあるという方針なので、こうやって自分なりにそのlink集を再現した方が理解がしやすくなると思う。オンライン・ドキュメントを読んで理解が深まるなら作業は増えても、うんうん唸る時間は減る。

#### 用語集

本文を読む前にざっとでいいから目を通しておくと、どの言葉が用語集にあるのか分かってよい。紙の文書だから、使っている用語をそのままハイパーリンクにできないのでこうしているのだと思うけど。


用語集が p711 からある。私のように用語の定義というか何を指しているのかを知りたがる人は先に目を通しておこう。 2020-07-12 の 06:10 時点で4章以前の疑問に思ったことはだいたい書いてある。最初から気がついていたら時間の節約もそうだし、悩む必要がなかった。

あと、本家の用語集(の日本語版)も目を通しておけとのこと。

- [用語集 — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/glossary.html)

## 点検読書I

### 「この本は何について書いたものであるか」

 (最後まで読み切れていないが、暫定版として)この本は、pythonの持っている力を引き出すメンタルモデルと、プログラミング方法について書いた本である。

### 「この本はどのように構成されているか」

まえがきのページ xii からの書いてある。拾い読みをするときに、いいガイドになるかも知れません。ただ、理解するには前に遡って読む必要があるかもしれません。

#### I部
#### II部
#### III部
#### IV部
#### V部
#### VI部


### 「どのような部分に分けられているか」

### 「この本は、どういう種類の本か」

pythonの能力を引き出す方法、pythonic? な方法について書いた本

## 1章 Pythonのデータモデル

pythonのデータモデルについて説明なしに知っている前提で書いています。ひとまずいろいろ棚上げして、辛抱強く最後まで読むとなんとなく分かります。一緒に、[3.データモデル](https://docs.python.org/ja/3.7/reference/datamodel.html)とか眺めておくといいかもしれません。

データモデルとは、何ぞやというのは、別の本でちゃんと定義されているのかもしれません。この章を読むと書いてある内容からなんとなく、「データモデル」とよんでいる物が、Pythonの根幹を為す、ダンダー[^ダンダー]についての話なんだなって。

Soapbox の、「データモデル?それともオブジェクトモデル?」で、もう少しヒントがでてくる。


Soapboxでは、他にjsとjavaの話がでてる。p16からp17にかけて。

lenがメソッドでないのは、そうとう議論になったから何度も出てくるんだろうね。やはり。

[^ダンダー]: ダンダーの話は、p4に載っています。

### 1.1 Pythonicなトランプ

- [collections --- コンテナデータ型 — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/library/collections.html?highlight=namedtuple#collections.namedtuple)

- 2〜10,J,Q,K,Aの配列
- namedtupleの利点は、固有のメソッドを持たないオブジェクトをのクラスを作れるようになった。以下は矢吹の推測だが、なんでもオブジェクトだとやりすぎで、シンプルなデータ構造を作ってメモリの有効活用をしたかったのではないか。

シントピカル読書
: Effective Pythonのp59で、namedtupleの限界というコラムがある。有用な場合と害の場合がある。とのこと。

### 疑問点

* Pythonのデータモデルとは、どのように説明したらいいのか。

### 読書会で、話題になったこと。

chatに貼り付けてもらったとか、話題にでたのを主に書き残しておく。

- Python 入門ノート
- [Python実践入門 ──言語の力を引き出し、開発効率を高める：書籍案内｜技術評論社](https://gihyo.jp/book/2020/978-4-297-11111-3)
- [Python Online | Online editor and compiler](https://paiza.io/en/projects/new?language=python3)
- [namedtupleで美しいpythonを書く！（翻訳） - Qiita](https://qiita.com/Seny/items/add4d03876f505442136)
    - namedtuple使いでがあるよね。って話
- DataClassも使いでがあるよね。いま読んでいるFluentPython日本語版は、主にpython3.3までの話題を取り扱っているので、DataClassの話はでてこないけど、discordのpythonコミュニティで話題になっていた。という話
    - [Pythonjp Discord Server](https://www.python.jp/pages/pythonjp_discord.html)
- pylanceの話題。
- 用語集は先に読んでおくといいね。
- 使っているpythonの開発環境の話題。ice breakにはいいかもね。
- Fluent Pythonのサンプルプログラムのライセンスは、MITであるとのこと。
    - [example-code/LICENSE at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/LICENSE)
    - [fluentpython/example-code: Example code for the book Fluent Python](https://github.com/fluentpython/example-code)
- [example-code/frenchdeck.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/01-data-model/frenchdeck.py)
- [example-code/vector2d.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/01-data-model/vector2d.py)

## 2章 シーケンスの配列

pythonに関係深い、ABCという言語の話が導入となる。

シーケンスって、なんだったかな。と、Python ボケットリファレンスの113pを参照しておく。クラス図からの説明になる。きっちりと言葉で説明するのは難しいが、こうやってクラス図で表されると何となくわかる。でも他人に説明できるかと言われると多分できない。

データの入った物が一列に並んでいるイメージを想定してください。って感じか。コンテナが並んでいる感じ。

### 2.1 組み込み型シーケンスの概要

で、シーケンスとはなにか?については既知として、分類から概要が始まる。

- コンテナ・シーケンス
- フラット・シーケンス

p22を参照。参照が入るか、実体のデータたちがはいるか。それぞれに、メリットとデメリットがある。

別の分け方として、

- mutable sequence
- immutable sequence

可変なシーケンス、不変なシーケンスという日本語がわりあたっているが、昨今ではカタカナの方が通りがよかったりする?そして書き換えができるか、できないか。の違いなので、自分のイメージにひきつけて理解することにした。

そして、図2-1 この図に見慣れないと、後から混乱しそう。向かって右が、子で、向かって左が、親の関係か。ここでは子から親に矢印が向かっている。と理解した。p23

### 2.2 リスト内包表記とジェネレータ式

シーケンスを作る手段として、リスト内包表記と、ジェネレータ式に言及じている。「読みやすくて速い」という著者の主張を読み進めることになる。

下記は省略語として、

- listcomp : リスト内包表記
- genexp : ジェネレータ式

という表現を知る。

- [ord 組み込み関数 — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/library/functions.html#ord)
    - 与えられたシンボルのコードを出力する。p24

p24の構文のヒントは役立った。ここで改行していいってのは、コードを見てなんとなくは分かっていたが文章で書いてもらえるのはありがたい。

p25のコラムは、python3の世界になったので、今となっては、python2のコードを書く必要がないかぎり忘れて良いのではないか。

#### 2.2.2 リスト内包表記とmap/filterの違い

pythonのlambdaか、機能的に足りないとは?　別の場所で言及はあるか。あと、何と比較して足りる足りないを著者は語っているのか。

例2-3のコードが、リスト内包表記とmap/filterで書いたコードを比較している。若干慣れの気がするかもしれないが、実行速度を比較するコード listcomp_speed.py があるので、差が分かるぐらいに違うんだろう。


#### 2.2.3 デカルト積

デカルト積という名前に、不安を抱く必要は無い。数学の順列・組み合わせを思い出せば良いみたい。または行列の積

#### 2.2.4 ジェネレータ式

全部を一度に作らなくても、実行するたびに値を返せば、使用メモリーを減らすことができるのは道理だ。

あと、ポケットリファレンスでは、yield文を使う例しか出てこなかったが、ここでは違う書き方があるで勉強になる。

#### 2.3.1 レコードとしてのタプル

RDBをよく使っていると、レコードというと、RDBで処理したらいいじゃないか。と、してしまいそうになるが、ここで書いてあるテクニックは、pythonらしい書き方というか、データ操作方法になると思う。ある程度データが大きくなるまではRDBへの依存がないプログラムの方が扱いが楽だし。依存を増やすのは後からでもできる。

#### 2.3.2 タプルのアンパック

ここでの、アスタリスクの使い方は、おまじないだとして引数などに付けていた、アスタリスクが、vividに意味を持ち始めた。あとタプルの値のスワップに、一時変数を使わなくても良いってのは、C言語からすると楽ではあるが、ちょっと落ち着かない。(内部ではちゃんとしているだろうから便利に使わせてもらうのてはある)


\_ は、文法でなく慣習であるというのは、前に調べていたのでよかった。また i18n への言及があるのは良い。ただ、これだけではない。p32

#### 2.3.3 ネストしたタプルのアンパック

ちょっとしたRDBの問い合わせみたいなことをここでは、タプルとアンパックを使って実現してる。p33

#### 2.3.4 名前付きタプル

僅かなメモリの増加を受け入れると、名前付きのタプルでこんな便利なことができるよ。と教えてくれる。プログラムをを書くにあたって確かに明確に意志を伝えるプログラムを書くことができるので使いたくなる。

本の範囲は外れるが、 python3.7からは、　[dataclasses --- データクラス — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/library/dataclasses.html) とかもあるのでデータを扱う引き出しが増えるので、ここにメモっておく。

#### 2.3.5 不変リストとしてのタプル

不変リスト = immutable

listとtupleの似ている点について、どこまで一緒なのかを確認すると違う部分に集中できるので良さそう。p35からp36

### 2.4 スライス

ここで扱うのは、python本体と一緒に配布されているライブラリの使い方であり、自分で同じような動作をするクラスを作るのは、第10章で扱うとのこと。

ここでは、あんまりできると思っていなかった使い方を知る。ごちゃごちゃ書かずにスパッとデータを書き換える方法がある。p39

NumPyと、SciPyについては、例外として言及している。p38


#### 2.5.1 リストのリストの生成

ここは、実体を回数分生成しているのか、参照を回数分生成しているのか。を、必要な時には思い出したい。p41


#### 2.6.1 +=による代入の謎

へー。としか。確かにコーナーケースである。

- [python tutor](http://www.pythontutor.com/live.html#code=t%20%3D%20%281,2,%20%5B30,40%5D%29%0At%5B2%5D%20%2B%3D%20%5B50,60%5D%0A&cumulative=true&curInstr=2&heapPrimitives=true&mode=display&origin=opt-live.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false)
    - pythonのlive programmingモードにしておく。

- byte codeを吐き出すのに、 [dis --- Python バイトコードの逆アセンブラ — Python 3.8.4rc1 ドキュメント](https://docs.python.org/ja/3/library/dis.html) を参照すること。`import dis`をしないとエラーになる。

### 2.7 list.sortと組み込み関数 sorted

Noneが返ると、chain methodにならない。逆説的に、chain methodを作る方法とするのがいいか。p45

### 2.8 bisectを使った順序付きシーケンスの処理

大量のデータから、できるだけ速く該当のデータを探し出すために、あるキー順にソートしてある前提でデーさ操作をすることがある。

身近な例でいうと、git bisect がキーワードとして似ているし、二分木探索の話はどのアルゴリズムの本なら触れているだろう。これまで読んだ本でおもしろかったのは、debugに、2分木法を使うという本を読んだときであった。

### 2.9 listを使わない方がよいケース

こいつ使って、いつ使わないかも知りたかった、

#### 2.9.1 配列

ここも読む価値がある。

#### 2.9.2 メモリービュー

Cのstructとunionの合わせ技みたいなことができるんや。

例 2-21に対するメモ
```bash
% echo "obase=16;ibase=10;1024"|bc
400
```

#### 2.9.3 NumPyとSciPy

この本では、基本的にはPythonに付属のライブラリの話をしているが、ここではタイトルの用に、NumPyとSciPyを扱う。

私は、Debian GNU/Linuxを使っており、お手軽に導入するため、`apt install python3-numpy python3-scipy`のコマンドで導入した。

#### 2.9.4 デックやその他のキュー

appendやpopメソッドを使えば、スタックやキューとして使えるし、inque,dequeについても書いてある。スレッドセーフなのが嬉しい。

ここも、スレッドセーフ、プロセス間通信、asyncioに対応した。queue関係の情報かある。そしてheapqがあるので一から作らなくても、シーケンスをヒープキューや優先順序付きのキューを提供してくれるとのことで、自分で書いてデバッグする時間を減らすことができそう。

### 2.10 本章のまとめ

一度読んでおけば、ここから情報を取るだけで思い出せることが増えて良さそう。p61-p62

### 2.11 参考文献

ここは、また戻ってきた時に参照する。一回目は軽くなぞるだけにする。

Soapboxの「すばらしいkey」については、心惹かれた。

## 3章 ディクショナリとセット

この章は、最初に概要を書いてくれている。良い。

pythonを使っていて、辞書(ディクショナリ/dict)型を使わないことはない。と言いきってもいいぐらい。ユーザーが作っているプログラムで多用されているだけでなく、

- モジュールの名前空間
- クラスとインスタンスの属性
- 関数のキーワード引数

などのpythonを支えている機能は、dict型で実装されている。これらはハッシュテーブル
で作られていることが明かされる。

この章では、ハッシュテーブルの仕組みを解説することで、pythonのdictとsetを活用する方法を学ぶことができるとある。

### 3.1 一般的なマップ型

map型とは一体 :thinking face: なりながら、読み進める。

- [collections --- コンテナデータ型 — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/library/collections.html)
    - 話は逸れるが、このへんは見ておこう。

- [collections.abc --- コレクションの抽象基底クラス — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/library/collections.abc.html#module-collections.abc)
    - 本命はこっち、以前は上記と一緒だったが、python3.3で分かれた。

p70の図3-1

Mappingと、MutableMappingの継承について書いてあるから、これがmap型の説明なんだと思う。言葉でなく、UML図で示す感じ。どういうメンバーというかメソッドがいるのか、ってのを理解するのはこっちの方がまどろっこしくないからいいのか。

特殊用途のマップの実装について、ここに記述がある。「抽象基底クラス」ではなく、dictまたは、collections.UserDictを拡張することについて書いてある。

dict型かどうかを検査するより、isinstanceを用いよ。という話

「ハッシュ可能とは」というコラムはp70からp71 オブジェクト比較の話だが、比較できない場合について述べてあるので、いつ使えて、いつ使えないのかを確認するために参照することになるかも。内部状態という概念は得た。

- [組み込み型 — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/library/stdtypes.html#mapping-types-dict)
    - 文書の中で言及しているは、この部分である。
    - ここの文書も一階層あがって読みきったから、この本書いているんだろうな。
    - 日本語版をpointしているので、4. Built-in Typesかどうかは見てない。例が同じそうだ。というのは軽く確認した。

### 3.2 ディクショナリ内包表記

リスト内包表記があるなら、ディクショナリも同じような書き方ができると類推できるよね。ってことか。p72

### 一般的なマップメソッドの概要

ここでも出てくるAPIという言葉。メソッドと何が違うのか、最初で定義しているのに読み飛ばしたかなと思えてきた。

ここの表も必要があれば参照したくなるだろう。dict,defaultdict,OrderedDictの差がわかる。

### 3.3.1 存在しないキーをsetdefaultで処理

ここで、「フェールファースト」の理念が出てくる。私はあんまり聞いたことがなかったので、監訳者の注で意味が補われていて予想した意味と異なっておらず助かった。ダックタイピングはけっこう聞くのでそこは気にならず。

この、setdefaultに関しては、持っているPythonポケットリファレンスの、P154 「9-3-8 デフォルト値付きの抽出」で、大まかな内容を知っているので、細かく挙動を書いてあるぽいことだけ確認した。

p75-o75 まずは、setdefaultを使わない方法を示して、p76で、setdefaultを使って解きなおししている。

### 3.4 柔軟なキー検索を使ったマップ

サーチしたキーが、存在しなかった時に、どういう扱いがいいかについて、2つの方法を提示している。

1. dictの代わりに、defautldictを使う
2. サブクラスを作って、\_\_missing\_\_ メソッドを追加する。

#### 3.4.1 defaultdict --- 存在しないキーの扱い方 その1

ここでは、サーチして最初に見つかったときに、エントリーを生成するプログラムを例として説明している。ようするに、KeyErrorを発生させない。

p78 のいつ呼び出されて、どういうときに呼び出されないか。は押さえておきたい。

#### 3.4.2 \_\_missing\_\_ メソッド --- 存在しないキーの扱い方 その2

\_\_missing\_\_ の定義の方法と、どのタイミングで、呼び出されるのかについて記述してある。これ、pythonの基礎的なメカニズムなんで、後から広く応用できるんではないだろうか。rubyのmissing\_methodのように。読み進めると分かるか。

これについても、何時使えて、いつ使えないのか書いてあるので、ここは後からも参照しそうな感じ。p78

\_\_missing\_\_ の実装で、isinstance のチェックが必要な理由についても読んでおきたい。

### 3.5 dictのバリエーション

- collections.OrderedDictの説明 p81
    - 挿入された順、デフォルトはqueueのような動作だが、stackのような動作をさせることもできる。
- collections.ChainMap の説明 p81
    - 複数のマップを一括でサーチできる。サクッと作って後からチューニングするのに便利そう。どう使うかの例は書いてある。
- collections.Counter の説明 p82
    - 最頻をカウントするのに便利そう。いくつか便利そうなメソッドも紹介している。
- collectgions.UserDict
    - 次の 3.6 で説明とのこと。

### 3.6 UserDictのサブクラス化

こっちを使う方が便利なんじゃないかなっていう指針を教えてくれる。UserDicTを使う前には、読んでおくとハマらずに短い時間でプログラムを作れそう。

### 3.7 不変マップ

immutable map 何時使うのか。についてはアイディアや必要性に迫られた時でいいか。その時に細かく読めば良いか。

### 3.8 セット

ポケットリファレンスのP155からp156にざっくりと書いてあるのを復習してからこの 3.8 を読む。

setについて。記述が古いのかあんまり使われていないとあるが、ハマると便利なんで使いこなしたい。classとしての、setとfrozenset

- 重複した要素を許さない。
    - これは、RDBの一意制約にも似て、使いでがある制約に感じる。
    - 本文中の「重複する要素を削除することが」[^重複する要素を削除することが]ってのは、結果としてそうなる。という意味に取らないと削除する動作を何時するんだってなりそう。
- Setの要素は、ハッシュ可能であること。Set自体はハッシュ不可能、Frozensetはハッシュ可能なので、Setの要素に、Set自身は使えないが、Froaensetは使える。
- このへんになってくると、数学の集合論を利用したくなるね。集合論的な操作できるし。ループや条件分岐を減らせるのは、コードが短くなって間違いの余地が減りそう。

[^重複する要素を削除することが]: p85の下から1行目

#### 3.8.1 リテラル

Setの構文で、だいたい数学と一緒なんだけど、空集合だけは別の書き方をするぜ。{}とかくと、意図に反して空のdictができてしまう。これって、間違えないようにする工夫はあるだろうか。型?

リテラルなset構文は、慣れれば意図は明解なので良いという主張。コンストラクターを使う呼び出し方法と、リテラルの処理で、BUILD\_SETバイトコードの実行の話になる。p87

バイトコードのdisアセンブラを見せながらの解説をしてくれる。

Frozensetには、リテラル表記はない。のでコンストラクタを呼び出すしかないとのこと。

#### 3.8.2 セット内包表記

をを、確かにセットも内包表記があってしかるべきだよな。p88

#### 3.8,3 セットの演算

ここで出てくる、「インプレイスで変更/更新」ってあんまり聞かない表現なんだけど。p88

ここで出てくるsetの操作をうまく使うとコードを短くできそう。

### 3.9 dictとsetの内部構造

内部構造の話だから、読み飛ばそうかなって思ったんだけど、性能やトレードオフの問題が書いてあるので、読み飛ばせなかった。ある程度経験を積んだプログラマなら気になることが書いてある。

この節では、
- Pythonのdictとsetはどれだけ効率的なのか。
- なぜ順序付きではないのか。
- 任意のPythonオブジェクトをdictのキーまたは、setの要素に使えないのはなぜなのか。
- dictのキーやsetの要素の順序が、挿入順に依存し、その構造が利用している間に変化することもあるのはどうしてなのか
- dictやsetに対してイテレーションを行っているとき、それらに要素を追加してはいけないのはなぜなのか

を、説明してくれる。とのこと。内部構造を知ることで、その得失点と(pythonの)低レイヤーを意識することで、性能と仕様を満たすバランスを考えることになるんだろうな。という感じか。メモを書きながら読んでいるので、後で訂正するかも。

#### 3.9.1 性能評価実験

じぶんのpython3の環境で、追試してみるのも良いが、いまではない。

#### 3.9.2 ディクショナリのハッシュテーブル

#### 3.9.3 dictの構造に起因する実用上の影響

ここは一読しただけでは、よく分からない。将来のためにメモだけ残しておく。

- p97 「ユーザ定義型のハッシュ値は、id()であり、それらを比較した結果はいつも等しくないため、元からハッシュ可能です。」って、「キーはハッシュ可能なオブジェクトでならなくてはいけない」とぱっと見に反しているので、補足が欲しい気がする。
    - 等しいということは、「ハッシュが同じ」である。\_\_eq\_\_() を実装する時に注意が必要っぽい。
- dictには顕著なメモリーオーバーヘッドがある。
    - ここは重要で、どうしたら良いのかの提案もある。ただし書いてあるように、早すぎた最適化は保守性を下げるので、手早く富豪的アプローチで作ってから最適化を考えるというのも動かさないと評価できないので、一つの知見でもあろう。
- キーサーチは非常に高速ってのは、スペースと時間がトレードオフになっている。アクセス時間はサイズに関係ない。サイズを指数的に大きくしても、影響はすくない。
    - ちゅうことは、この辺が実用的なpythonのプログラムを作るに当たっての勘どころなのか?
- dictに要素を追加するとキーの既存の順序が変更される可能性がある
    - これ知っておかないとハマるだろう。既存と更新用に分けたら良いだけ。富豪的アプローチだけど副作用を考えたらね。こんな感じで困るぐらいカツカツの環境なら、言語とか仕様とか考え直して実装したほうがいいんじゃないだろうか。まずはpythonでつくって仮説を検証するでかなりの所までいけるでしょう。

#### 3.9.4 セットの挙動

これまで記述してある内容の重複をさけるためにあっさりとしているが、これもsetを使う上では勘案することである。p99-p100

### 3.10 本章のまとめ

ここも、一度通読してから、読み直して頭に定着させるためにいい感じ。

### 3.11 参考文献

あとでリンク貼る。

ここのSoapbox p101-p102 は、いまいち理解できず。ハッシュの機構がシンプルだというのは、同意できるが、正確だというのは、何に対してどう正確なのか、理解できてない。他の言語の記述方法に似ていることと正確さに何の関連があるのか。正確というのは何かの基準があってそこへの差分が一定範囲内だという理解なので、いまいちピンときていないのだと思う。

## 4章 テキストとバイト

ここは、どのぐらいの事前知識を必要とするのだろうか。Unicodeのの時代だし、CJKに深く突っ込む所でもないから、文字コード本みたいな副読本はいらないかもしれない。とか思ったが、そんなことなさそう。Unidodeのバージョンの話がでてくるから、制定の話と改訂の話ぐらいは知っておくのは、この本を読む前に知っとけということ。

文字とバイトを区別するという話なので、まずは読み進めてみる。下記のトピックについて解説するとある。

- 文字、コードポイント、およびバイト表現
- bytes, bytearrary,memoryviewといったバイナリーシーケンス固有の機能
- Unicodeおよび従来型の文字セットの完全なコーデック
- エンコーディングエラーの回避と処置
- テキストファイル処理におけるベストプラクティス
- デフォルトエンコーディングと標準入出力の問題
- 正規化による安全なUnicodeテキストの比較
- 正規化、ケースフォールディング、付加記号を強引に除去するユーティリティ関数
- localeとPyUCAライブラリを用いたUnicodeテキストの的確なソート
- 文字とメタデータを収録したUnicodeデータベース
- strとbytesを処理するデュアルモードAPI

はい。もうこの段階で、Codecが具体的に何を指しているのか、とか、Unicodeの正規化について具体的なイメージが沸かないので中身を読み進めたくなってきました。
ケースフォールディングに関しては、監訳者の注があるので意味が分かりました。MySQLとかでも問題になっていた件をpythonでどう解決するではないかと思いましたが、当たっているかどうかは読み進めてみないと分かりません。最初印象ってか予期しているバイアスを書いておいて後から自分で修正するスタイルで。

### 4.1 文字の問題

Unicodeをpythonで扱ってみて、皆さん慣れてくださいね。のパートです。

もうpython3に移行していると思うので、python2の記述は過去の資産をメンテする必要がなければ、読み飛ばしていきます。

### 4.2 バイトについて

C言語をやったことがあれば、unsigned charとか、unsigned char \* で操作してる感じよね。って感じの話っぽい。低レベルな技術者[^低レベルな技術者]なら、するすると読み下せそう。

[^低レベルな技術者]: 誤解させる言い方ですね。正確には、低レベルのレイヤーを対象する技術者、アセンブラ/C言語でのシステムプログラミング以下、組み込み系とか、OSとかを触る感じの人です。

ここで出てくる、encodeとdecodeの例えは、図があったほうがいいな。本に落書きするか。

#### 4.2.1 structとメモリビュー

これ、まんまC言語のstructで型にハメるやりかたや。memoryviewでunionってか参照させる感じなんや。こんな低レイヤなことできるんだな。

### 4.3 基本的なエンコーダとデコーダ

エンコーダとデコーダの両方を指す言葉として、コーデックと呼んでいるのがここに来てわかった。

参考になるが、CJKの本ではないので、日本語を扱うのであれば、Linux上でつかっているし、utf-8一択だな。発展的に調べるとCP932とかも多分あるんだろうけど。

サロゲートペアの説明をp111でしているのは良い。

### 4.4 エンコードとデコードの問題点

以下で個別に、エラーへの対処策が書いてあるので、困ったときにはそこを読めば良いってのは、困っている人向けに書いているからだろうな。

#### 4.4.1 UnicodeEncodeErrorへの対処策

P112-p112

#### 4.4.2 UnicodeDecodeerrorへの対処策

p113-p114

#### 4.4.3 予期しないエンコーディングでモジュールをロードしたときのSyntaxError

p114-p115

コラムの「ソースコードでASCII文字でない名前を使ってよいものでしょうか」はおもしろい
が使っていいときと使ってよくない時があるし、思っている以上に使われる可能性があるなら
やめとけなんだろうね。

#### 4.4.4 バイトシーケンスのエンコーディングを知る方法

そりゃそうだろうな。知っている所から(生成側)から教えないと正確な所は分かるまい。できても推測までで、身近な例だとブラウザがやっている。長い文字列なら判別できるが、短いと文字化けした経験はあるだろう。

#### 4.4.5 便利だけど厄介なBOM

UTF16エンコードのBOMの話です。GNU/LinuxならUTF8で幸せなんだけど。P117-P118

### 4.5 テキストファイルの処理

GNU/Linux環境なら、デフォルトがUTF8なのでこれに悩むことはないが、他のエンコードをもつシステムとデータのやりとりをする必要があるなら読んでおこう。ネット上にも記事はあるが、せっかく買ってあるのだから読めば良い。P118-P121

#### 4.5.1 大混乱なデフォルトエンコーディング

使っているOSで、どういう風にデフォルトエンコーディングになっているかの説明をしている。確認方法を提供しているので、混乱したらここから調査を開始するのもいいかと。P121-P124

### 4.6 適切な比較のためのUnicodeの正規化

ソートを含めて文字の大小比較をどうするかについて。アクセント記号の話題だったりするが、日本語でもまったく関係ないわけでもない。うに濁点とか。絵文字とか。は本書で取り上げていないけど関係ある。あと検索時にアクセント記号をつけていなくても付けているの同じように検索したいとかありそうな仕様ですし。日本語だとカタカナだろうがひらかなだろうが、同一視したいとか。と考えたらいいのかな。

本文例だと、1/2を3文字のASCIIで入力してもUnicodeの一文字1/2を同一視することを書いている。

監訳者注で、NFC,NFD,NFKC,NFKDについて略していない用語をだしている。これらの意味を知りたいならUnicode本が必要っぽい。この辺書いた本があれば後でここに書き足そう。文字コードの本は何冊かあるはず。オンラインで検索してもいいけども

P124-P127

#### 4.6.1 ケースフォールディング

基本的には、すべての文字列を小文字に変換することなのか。例外もある。が本文を参照してほしい。p127

#### 4.6.2 テキストを正規化してから比較するユーティリティ関数

NFCとNFDが出てくるが、p125 で用語の説明がしてある。

#### 4.6.3 付加記号う取り除く極端な正規表現

著者としては、力のはいっている部分なんだろうと思う。でも日本語話者としては、もっと身近な例がいいな。

p128-o133

### 4.7 Unicodeテキストのソート

localeに応じてソート。GNU/Linuxなら充分に動くが、...

#### 4.7.1 Unicode照合アルゴリズムでソート

ここで、PyUCAが出てくる。localeは見ずに、結果をカスタマイズすることができる。GNU/Linux以外の人には朗報だね。p135

### 4.8 Unicodeデータベース

- [Unicode HOWTO — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/howto/unicode.html)
    - これも副読文書としてリンクしておこう。
- [unicodedata --- Unicode データベース — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/library/unicodedata.html)

正規表現については、いまでもPyPIの方が優れているのだろうか。新しいバージョンで更新されているのかとか確認する方法は、簡単に分かったりしないのだろうか。開発を追っかけるのが堅い手ではあるのだけども。

### 4.9 str/bytes デュアルモードAPI

#### 4.9.1 正規表現におけるstrとbytes

具体例がでてくる。

CJKのってか、日本語の場合は??

#### 4.9.2 OSモジュールにおけるstrとbytes

GNU/Linux上での説明に始まり、他のプラットホームはそこそこ。

この扱いをみていると、一番便利なのはGNU/Linux上でUTF8で使うことで、私はそのど真ん中の例なんだな。

### 4.10 本書のまとめ

これ理解するのは、本当に大変で、資料を読んで、自分の卑近て例だけでわかった気になるとヤバいやつだというのはわかった。GNU/Linux上で、Pythonを使っている幸せを感じてポーティングするより windowsとかでもwsl2もあることだし、そっちで何とかしてくれと言うのが良さそう。もうUTF8で幸せになろうよ。ってのが私の感想です。

## 5章 第一級関数

最初に、Guidoが、関数型言語から影響を受けたとは思っていないという引用から始まる。しかしこれを明言しない理由は何だったんだろうか。

2020-07-12 06:47

第一級関数=第一級オブジェクトの定義を読んでいて、気になることがある。

- ランタイムに生成できる。
- データ構造の中の変数や要素に代入できる
- 関数の引数として渡すことができる
- 関数の結果として返すことができる

で、最初のランタイム[^ランタイム]に生成できる。というのに違和感がある。ランタイムは、実行バイナリのことを指してランタイムということがある。が、pythonの場合コンバイラとしてバイナリを吐き出すのが、いつでも成り立つ訳ではない。実行している時にとか、プログラムを実行している間にとか、そういう意味ではないのか。

[^ランタイム]: REPLのことをコンソールセッションと呼び、関数を「ランタイム」で生成しているので、実行可能バイナリのことを指してランタイムと呼んでいるわけではなさそうです。

関数が第一オブジェクトでない言語って、BASICとかかな。最近の言語だと可能なのが多いので分からんようになるわ。

### 5.1 関数をオブジェクトのように扱う

実例をだしている。

### 5.2 高階関数

ここでの高階関数の定義は、「関数を引数として受け取ったり、結果として関数を返したりする関数」とのこと。この定義は、ボケットリファレンスのp268にある 「16-1-3 高階関数を使う」においても同じ内容であった。

#### 5.2.1 map,filter,reduceの最新の代替

もう、python2は考慮しなくてよいものとして読むスピードを上げる。

map,filter,reduceよりも、リスト内包表記やジェネレータ式で代替できるので、使われなくなった。というのは、なるほどと思った。パイソン風(pythonic)なプログラミングでは、そう書くのだと。例5-5でmapをリスト内包表記に書き換えている実例を出している。

例 5-6 で、reduceを使う典型例として、合計値を求めるのに、sumを使う例を出している。

mapとfiltgerは、ジェネレータを返すので、その扱いを変えるのが良いという話である。これも使う関数を真似るのではなく、使っている真意をマネよってことで。読んでよかったなと。

一つの値というか結果に「集約」するというのが、キモだということ。

あとの10.5や、14.11 でのイテラブルについても言及すると先触れを出していている。

ちなみに、ポケットリファレンスでは該当するページはp269-p271であるが、ここの部分の学びについては書いていないので、自分で追記しておく。

### 5.3 無名関数

lambdaの話。

いつ使えが明解でよい。


頑張りすぎて、わかりににくいlambdaを除去するリファクタリングレシピもいい。p154

- [関数型プログラミング HOWTO — Python 3.7.8 ドキュメント](https://docs.python.org/ja/3.7/howto/functional.html)
    - これは、Fluent Pythonが勧めているリンクである。そして、このhowtoが公式に取り込まれているのも、最初のGuido氏の言葉の引用はいったい。著者の冗談と取るべきなのか。それとも?

### 5.4 7つの呼び出し可能オブジェクト

呼び出しオブジェクトについて、列挙し、コメントをして理解しやすくしてくれている。後のために、ジェネレータ関数の所で、コルーチンについて言及している。また呼び出し可能か判定するのは、そのオブジェクトのcallable()を呼んでみる。のを実例を入れて書いている。p154-p156

### 5.5 呼び出し可能なユーザ定義型

[example-code/bingocall.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/05-1class-func/bingocall.py)
    - インスタンス化する時にクラスを実行する
    - インスタンス化したオブジェクトを実行すると、 \_\_call\_\_(self):を定義してどんな戻り値にするか決めることができる。

疑問点
: p157で書いてある、クラスに、 \_\_call\_\_ を実装すれば、の下りは、ここで何を言っているのか意味がよく分からない。他の人とも議論してみたい。

### 5.6 関数のイントロスペクション

### 5.10 関数型プログラミングのためのパッケージ

純粋な関数型プログラミングう行うというよりも、lru\|cache などのデコレータを便利に使うための手段して関数型を取り込んでいるというのが、後から読み直した時の所感です。便利に使うためにはA事前に学んでおかないといけないので、後で効いてくる。



## 6章 第1級関数を使ったデザインバターン

see also オライリーの実践python3の方が、デザインパターンについて詳しいのであるが、本書では、Strategry のパターンについて繰り返しpythonの異なる機能を用いて紹介している。

### 6.1 リファクタリングのケーススタディとしての Strategy パターン

#### 6.1.1 典型的な Strategy パターン

抽象基底クラス(ABC) として使うために、@abstractmethodデコレータを使っている。7章を読んだ後だと、やはりpythonは、デコレータの使いこなさないといけない。

#### 6.1.2 関数指向の Strategy パターン

#### 6.1.3 シンプルな方法による最良の Strategy の選択

気をつける点について、解決方法を下記で解決策を提示している。

#### 6.1.4 モジュールにある Strategy を検索

* globals()を使って関数を見つける
* イントロスペクションを使う

詳細は、本書のp186-p187を参照せよ。

### Command パターン

図6-2 p188のUML図

実行するコマンドのリストを生成する、より高度なundoを実装するためのヒントを提案してくれている。 \_\_call\_\_ メソッドをわかってからここにくる必要がある。

### 6.3 本章のまとめ

Design Pattern は、金科玉条でなく、言語の特性を応じて、コードの書き方でなくアイデアを活かして実装する話である。なので、他言語で慣れていても、pythonらしい書き方をする。(Fluent python)にあてはめ、こういう風にするのだ。ということを著者は言いたかったのだろうな。と思いながら読んだ。

### 6.4 参考文献

Soapboxで、7章に、Visitorパターンを作るときに、有用であるという、ジェネリック関数を予告している。また、CLOSのマルチメソッド[^CLOSのマルチメソッド]など予告しており、脳内の関連情報を読者に伝えたい意図を感じた。

[^CLOSのマルチメソッド]: LISPの話? [clojure - common lisp wikipedia - 解決方法](https://code.i-harness.com/ja-jp/q/91c501) や一般的には、[多重ディスパッチ - Wikipedia](https://ja.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E3%83%87%E3%82%A3%E3%82%B9%E3%83%91%E3%83%83%E3%83%81) とも呼ぶようだ。

## 7章 関数デコレータとクロージャ

デコレータを使いこなすためには、クロージャの理解が必要とのこと。

p194にある。

- Pythonのデコレータ構文の評価方法
- 変数がローカルであるかを Python が判断する方法
- クロージャの存在意義とその挙動
  nonlocalで解決できる問題

上記の説明をこの章で受けて、クロージャの挙動がよくわかったので、とても良かった。python ポケットリファレンスでは、端的に説明されていて、理解できていなかった。これは、ボケットリファレンスなので、この様な概念をキチンと説明するのは荷が重いのは理解するが、重要な概念だけに省くことはできなかったのだろうな。とも思う。プログラミング経験者が、pythonの教科書を購入するなら、ここは一つ内容を確認しておくのがいいのではないか。と私は思う。もちろん、もう理解しているから要らないと意見もあるかもしれない。

### 7.1 デコレータの基礎

どういう動作をするか。についてのチュートリアル。

### 7.2 デコレータ実行のタイミング

ここのキモは、デコレータの実行タイミングを書いており、インポート時に何が起きているのか。を書いている所です。たしかに、そういう風に動くにはこのタイミングか。というのは理解できる。

### 7.3 デコレータを使った Strategy パターンの改善

例7-3は、[example-code/strategy_best4.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/strategy_best4.py) が該当する

動いているコードで、理解を深めるのがいい。

### 7.4 変数スコープ

ここで、pythonでのスコープを確認する。

例7-4, 例7-5 は、[example-code/global_x_local.rst at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/global_x_local.rst)　が該当するようだ。

ローカル変数を、globalとして扱うための説明で、nonlocalの説明の前フリである。

### 7.5 クロージャ

クロージャは、理解されにくいのか。違うモノと混同されている。

- 例 7-8
    - [example-code/average_oo.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/average_oo.py)
- 例 7-9
    - [example-code/average.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/average.py)


図 7-1 ここの自由変数の図を読もう。

これ、例7-11 例7-12など

### 7.6 nonlocal宣言

例 7-13 例 7-14 も既存か。

ここの説明が、python3になって、nonlocalが導入された説明になる。python2においてのやり方が書いている。p206

### 7.7 シンプルなデコレータの実装

#### 7.7.1 コードの解説

\_\_name\_\_ と \_\_doc\_\_ を覆い隠さないバージョン で、なんでこうなるかについても説明している。

functoolsのなかにある functools.wraps は、[functools --- 高階関数と呼び出し可能オブジェクトの操作 — Python 3.8.5 ドキュメント](https://docs.python.org/ja/3/library/functools.html?highlight=functools%20wraps#functools.wraps) であり、functools.update\_wraps [functools --- 高階関数と呼び出し可能オブジェクトの操作 — Python 3.8.5 ドキュメント](https://docs.python.org/ja/3/library/functools.html?highlight=functools%20wraps#functools.update_wrapper) を呼んでいるので、こっちも見る必要がある。

### 7.8 標準ライブラリのデコレータ

property, classmethod, staticmethodの説明は後にするとのこと。functools.wraps は、既に紹介した。lru\_cacheとsingledispatchの説明をするとのこと。

#### 7.8.1 functools.lru\_cache を用いたメモ化

メモ化
: ここのnoteの主旨からは外れるかも知れないが、lru\_cache を「メモ化」という表現は、pythonにおける定訳だと気がつくまで、かなり違和感があった。
lru\_cacheの概念を「メモ化」という概念で日本語として互換だと消化するまでに時間がかかったからです。記録してすぐに参照するというコアなアイディアを共有すると良かったのだと今にしては思う。納得しがたかったのは、自分が、lru\_cacheの動作の方から考えていたからなのだろう。

ここでのコア・アイディアは、一回実行した結果をlru方式で記録しておく。その時の条件として、入力が一定なら、必ず同じ出力をするのであれば再利用が可能だから。というもの。なので引数と出力をメモっておく。ただ気をつけないといけないのは、プログラム内部で、乱数や時刻などを参照していると同じ結果にならないので、何でもかんでもメモ化していいという話にはならない。

また、キャッシュをシステムで多重に持つと副作用があるので、どのレイヤーて何のキャッシュを持っているのか。を設計時に決めておかないといけない気がする。そのためには、最初からパフォーマンス計測を計画して、プログラムに組み込んでおく用心深さがいるのかもしれない。

当てずっぽでなく、データを収集する。は、話がfluent pythonから脱線したが、デコレータで気軽につかえるlru\_cacheは、プログラミングテクニックとして、覚えておくのは良い。ちょっとずつ違うことを繰り返し参照する場面では強力な手助けになるだろう。

- [example-code/fibo_demo.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/fibo_demo.py)
- [example-code/fibo_demo_lru.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/fibo_demo_lru.py)

#### 7.8.2 シングルディスパッチのジェネリック関数

- [example-code/generic.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/generic.py)

パッと見には、JavaやC++のオーバーロードと同等に感じるかも知れないが、p215で書かれている内容を、いまは理解できていない。得失点まで含めて人に説明できるようにならないと理解したとは言えないだろうし。

ここでの、抽象基底クラス(ABC)推しも、体感してみるのと、その便利さは何が代償なのかを確認しないとよくわからない。コードの拡張性とのトレードオフは、実行速度だったりすることもある。でも、pythonで書いている時点で、ある程度割り切りはできているはずで、その基準内であれば拡張性を優先するのはありえる話です。

### 7.9 多重デコレータ

デコレータを複数回実行すると何が起きているのかを記述している。p214

pythonポケットリファレンスのp273 16-1-7 デコレータ構文を利用する

の記述では、よくわからない挙動の確認に。ここと次の部分は有用だと感じた。

### 7.10 パラメータ化デコレータ

- [example-code/registration.py at master · fluentpython/example-code](https://github.com/fluentpython/example-code/blob/master/07-closure-deco/registration.py)

p216 の本節の最初の行を、なぜにpythonポケットリファレンスは、書いていないのか。経験を積むとわかるのだろうか。でも紙面が少ないから削られたのか。わからないけどもここは、自分で書き込みをして補っておく場面だよな。

いや、本に書き込むスペースぐらいでは足りないので、書き付けた紙を挟んでおくと、まだまだ書けるぞ。

#### 7.10.1 登録デコレータのパラメータ化

p217 ここで、デコレータファクトリの説明をしている。

#### 7.10.2 clockデコレータのパラメータ化

### 7.11 本章のまとめ

メタプログラミングの入り口かぁ。

### 7.12 参考文献

Soapbox の「自由変数」に関する記述が気になった。

あと、pythonのデコレータと、デザインパターンのDecorator

## 8章 オブジェクト参照、可変性、リサイクル



